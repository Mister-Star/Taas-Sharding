/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "hbase_server/hbase_types.h"

#include <thrift/TToString.h>

#include <algorithm>
#include <ostream>

namespace apache { namespace hadoop { namespace hbase { namespace thrift2 {

int _kTDeleteTypeValues[] = {
  TDeleteType::DELETE_COLUMN,
  TDeleteType::DELETE_COLUMNS,
  TDeleteType::DELETE_FAMILY,
  TDeleteType::DELETE_FAMILY_VERSION
};
const char* _kTDeleteTypeNames[] = {
  "DELETE_COLUMN",
  "DELETE_COLUMNS",
  "DELETE_FAMILY",
  "DELETE_FAMILY_VERSION"
};
const std::map<int, const char*> _TDeleteType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTDeleteTypeValues, _kTDeleteTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TDeleteType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDeleteType_VALUES_TO_NAMES.find(val);
  if (it != _TDeleteType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TDeleteType::type& val) {
  std::map<int, const char*>::const_iterator it = _TDeleteType_VALUES_TO_NAMES.find(val);
  if (it != _TDeleteType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTDurabilityValues[] = {
  TDurability::USE_DEFAULT,
  TDurability::SKIP_WAL,
  TDurability::ASYNC_WAL,
  TDurability::SYNC_WAL,
  TDurability::FSYNC_WAL
};
const char* _kTDurabilityNames[] = {
  "USE_DEFAULT",
  "SKIP_WAL",
  "ASYNC_WAL",
  "SYNC_WAL",
  "FSYNC_WAL"
};
const std::map<int, const char*> _TDurability_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDurabilityValues, _kTDurabilityNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TDurability::type& val) {
  std::map<int, const char*>::const_iterator it = _TDurability_VALUES_TO_NAMES.find(val);
  if (it != _TDurability_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TDurability::type& val) {
  std::map<int, const char*>::const_iterator it = _TDurability_VALUES_TO_NAMES.find(val);
  if (it != _TDurability_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTConsistencyValues[] = {
  TConsistency::STRONG,
  TConsistency::TIMELINE
};
const char* _kTConsistencyNames[] = {
  "STRONG",
  "TIMELINE"
};
const std::map<int, const char*> _TConsistency_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTConsistencyValues, _kTConsistencyNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TConsistency::type& val) {
  std::map<int, const char*>::const_iterator it = _TConsistency_VALUES_TO_NAMES.find(val);
  if (it != _TConsistency_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TConsistency::type& val) {
  std::map<int, const char*>::const_iterator it = _TConsistency_VALUES_TO_NAMES.find(val);
  if (it != _TConsistency_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTReadTypeValues[] = {
  TReadType::DEFAULT,
  TReadType::STREAM,
  TReadType::PREAD
};
const char* _kTReadTypeNames[] = {
  "DEFAULT",
  "STREAM",
  "PREAD"
};
const std::map<int, const char*> _TReadType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTReadTypeValues, _kTReadTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TReadType::type& val) {
  std::map<int, const char*>::const_iterator it = _TReadType_VALUES_TO_NAMES.find(val);
  if (it != _TReadType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TReadType::type& val) {
  std::map<int, const char*>::const_iterator it = _TReadType_VALUES_TO_NAMES.find(val);
  if (it != _TReadType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTCompareOpValues[] = {
  TCompareOp::LESS,
  TCompareOp::LESS_OR_EQUAL,
  TCompareOp::EQUAL,
  TCompareOp::NOT_EQUAL,
  TCompareOp::GREATER_OR_EQUAL,
  TCompareOp::GREATER,
  TCompareOp::NO_OP
};
const char* _kTCompareOpNames[] = {
  "LESS",
  "LESS_OR_EQUAL",
  "EQUAL",
  "NOT_EQUAL",
  "GREATER_OR_EQUAL",
  "GREATER",
  "NO_OP"
};
const std::map<int, const char*> _TCompareOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTCompareOpValues, _kTCompareOpNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TCompareOp::type& val) {
  std::map<int, const char*>::const_iterator it = _TCompareOp_VALUES_TO_NAMES.find(val);
  if (it != _TCompareOp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TCompareOp::type& val) {
  std::map<int, const char*>::const_iterator it = _TCompareOp_VALUES_TO_NAMES.find(val);
  if (it != _TCompareOp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTBloomFilterTypeValues[] = {
  /**
   * Bloomfilters disabled
   */
  TBloomFilterType::NONE,
  /**
   * Bloom enabled with Table row as Key
   */
  TBloomFilterType::ROW,
  /**
   * Bloom enabled with Table row &amp; column (family+qualifier) as Key
   */
  TBloomFilterType::ROWCOL,
  /**
   * Bloom enabled with Table row prefix as Key, specify the length of the prefix
   */
  TBloomFilterType::ROWPREFIX_FIXED_LENGTH
};
const char* _kTBloomFilterTypeNames[] = {
  /**
   * Bloomfilters disabled
   */
  "NONE",
  /**
   * Bloom enabled with Table row as Key
   */
  "ROW",
  /**
   * Bloom enabled with Table row &amp; column (family+qualifier) as Key
   */
  "ROWCOL",
  /**
   * Bloom enabled with Table row prefix as Key, specify the length of the prefix
   */
  "ROWPREFIX_FIXED_LENGTH"
};
const std::map<int, const char*> _TBloomFilterType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTBloomFilterTypeValues, _kTBloomFilterTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TBloomFilterType::type& val) {
  std::map<int, const char*>::const_iterator it = _TBloomFilterType_VALUES_TO_NAMES.find(val);
  if (it != _TBloomFilterType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TBloomFilterType::type& val) {
  std::map<int, const char*>::const_iterator it = _TBloomFilterType_VALUES_TO_NAMES.find(val);
  if (it != _TBloomFilterType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTCompressionAlgorithmValues[] = {
  TCompressionAlgorithm::LZO,
  TCompressionAlgorithm::GZ,
  TCompressionAlgorithm::NONE,
  TCompressionAlgorithm::SNAPPY,
  TCompressionAlgorithm::LZ4,
  TCompressionAlgorithm::BZIP2,
  TCompressionAlgorithm::ZSTD
};
const char* _kTCompressionAlgorithmNames[] = {
  "LZO",
  "GZ",
  "NONE",
  "SNAPPY",
  "LZ4",
  "BZIP2",
  "ZSTD"
};
const std::map<int, const char*> _TCompressionAlgorithm_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTCompressionAlgorithmValues, _kTCompressionAlgorithmNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TCompressionAlgorithm::type& val) {
  std::map<int, const char*>::const_iterator it = _TCompressionAlgorithm_VALUES_TO_NAMES.find(val);
  if (it != _TCompressionAlgorithm_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TCompressionAlgorithm::type& val) {
  std::map<int, const char*>::const_iterator it = _TCompressionAlgorithm_VALUES_TO_NAMES.find(val);
  if (it != _TCompressionAlgorithm_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTDataBlockEncodingValues[] = {
  /**
   * Disable data block encoding.
   */
  TDataBlockEncoding::NONE,
  TDataBlockEncoding::PREFIX,
  TDataBlockEncoding::DIFF,
  TDataBlockEncoding::FAST_DIFF,
  TDataBlockEncoding::ROW_INDEX_V1
};
const char* _kTDataBlockEncodingNames[] = {
  /**
   * Disable data block encoding.
   */
  "NONE",
  "PREFIX",
  "DIFF",
  "FAST_DIFF",
  "ROW_INDEX_V1"
};
const std::map<int, const char*> _TDataBlockEncoding_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTDataBlockEncodingValues, _kTDataBlockEncodingNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TDataBlockEncoding::type& val) {
  std::map<int, const char*>::const_iterator it = _TDataBlockEncoding_VALUES_TO_NAMES.find(val);
  if (it != _TDataBlockEncoding_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TDataBlockEncoding::type& val) {
  std::map<int, const char*>::const_iterator it = _TDataBlockEncoding_VALUES_TO_NAMES.find(val);
  if (it != _TDataBlockEncoding_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kTKeepDeletedCellsValues[] = {
  /**
   * Deleted Cells are not retained.
   */
  TKeepDeletedCells::FALSE,
  /**
   * Deleted Cells are retained until they are removed by other means
   * such TTL or VERSIONS.
   * If no TTL is specified or no new versions of delete cells are
   * written, they are retained forever.
   */
  TKeepDeletedCells::TRUE,
  /**
   * Deleted Cells are retained until the delete marker expires due to TTL.
   * This is useful when TTL is combined with MIN_VERSIONS and one
   * wants to keep a minimum number of versions around but at the same
   * time remove deleted cells after the TTL.
   */
  TKeepDeletedCells::TTL
};
const char* _kTKeepDeletedCellsNames[] = {
  /**
   * Deleted Cells are not retained.
   */
  "FALSE",
  /**
   * Deleted Cells are retained until they are removed by other means
   * such TTL or VERSIONS.
   * If no TTL is specified or no new versions of delete cells are
   * written, they are retained forever.
   */
  "TRUE",
  /**
   * Deleted Cells are retained until the delete marker expires due to TTL.
   * This is useful when TTL is combined with MIN_VERSIONS and one
   * wants to keep a minimum number of versions around but at the same
   * time remove deleted cells after the TTL.
   */
  "TTL"
};
const std::map<int, const char*> _TKeepDeletedCells_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTKeepDeletedCellsValues, _kTKeepDeletedCellsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const TKeepDeletedCells::type& val) {
  std::map<int, const char*>::const_iterator it = _TKeepDeletedCells_VALUES_TO_NAMES.find(val);
  if (it != _TKeepDeletedCells_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TKeepDeletedCells::type& val) {
  std::map<int, const char*>::const_iterator it = _TKeepDeletedCells_VALUES_TO_NAMES.find(val);
  if (it != _TKeepDeletedCells_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TTimeRange::~TTimeRange() noexcept {
}


void TTimeRange::__set_minStamp(const int64_t val) {
  this->minStamp = val;
}

void TTimeRange::__set_maxStamp(const int64_t val) {
  this->maxStamp = val;
}
std::ostream& operator<<(std::ostream& out, const TTimeRange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTimeRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_minStamp = false;
  bool isset_maxStamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minStamp);
          isset_minStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxStamp);
          isset_maxStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_minStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_maxStamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTimeRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTimeRange");

  xfer += oprot->writeFieldBegin("minStamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->minStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxStamp", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->maxStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTimeRange &a, TTimeRange &b) {
  using ::std::swap;
  swap(a.minStamp, b.minStamp);
  swap(a.maxStamp, b.maxStamp);
}

TTimeRange::TTimeRange(const TTimeRange& other0) noexcept {
  minStamp = other0.minStamp;
  maxStamp = other0.maxStamp;
}
TTimeRange& TTimeRange::operator=(const TTimeRange& other1) noexcept {
  minStamp = other1.minStamp;
  maxStamp = other1.maxStamp;
  return *this;
}
void TTimeRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTimeRange(";
  out << "minStamp=" << to_string(minStamp);
  out << ", " << "maxStamp=" << to_string(maxStamp);
  out << ")";
}


TColumn::~TColumn() noexcept {
}


void TColumn::__set_family(const std::string& val) {
  this->family = val;
}

void TColumn::__set_qualifier(const std::string& val) {
  this->qualifier = val;
__isset.qualifier = true;
}

void TColumn::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other2) {
  family = other2.family;
  qualifier = other2.qualifier;
  timestamp = other2.timestamp;
  __isset = other2.__isset;
}
TColumn& TColumn::operator=(const TColumn& other3) {
  family = other3.family;
  qualifier = other3.qualifier;
  timestamp = other3.timestamp;
  __isset = other3.__isset;
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier="; (__isset.qualifier ? (out << to_string(qualifier)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ")";
}


TColumnValue::~TColumnValue() noexcept {
}


void TColumnValue::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnValue::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnValue::__set_value(const std::string& val) {
  this->value = val;
}

void TColumnValue::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TColumnValue::__set_tags(const std::string& val) {
  this->tags = val;
__isset.tags = true;
}

void TColumnValue::__set_type(const int8_t val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tags);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnValue");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->tags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_BYTE, 6);
    xfer += oprot->writeByte(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnValue &a, TColumnValue &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.tags, b.tags);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

TColumnValue::TColumnValue(const TColumnValue& other4) {
  family = other4.family;
  qualifier = other4.qualifier;
  value = other4.value;
  timestamp = other4.timestamp;
  tags = other4.tags;
  type = other4.type;
  __isset = other4.__isset;
}
TColumnValue& TColumnValue::operator=(const TColumnValue& other5) {
  family = other5.family;
  qualifier = other5.qualifier;
  value = other5.value;
  timestamp = other5.timestamp;
  tags = other5.tags;
  type = other5.type;
  __isset = other5.__isset;
  return *this;
}
void TColumnValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnValue(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier=" << to_string(qualifier);
  out << ", " << "value=" << to_string(value);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


TColumnIncrement::~TColumnIncrement() noexcept {
}


void TColumnIncrement::__set_family(const std::string& val) {
  this->family = val;
}

void TColumnIncrement::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}

void TColumnIncrement::__set_amount(const int64_t val) {
  this->amount = val;
__isset.amount = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnIncrement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->amount);
          this->__isset.amount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnIncrement");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->family);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.amount) {
    xfer += oprot->writeFieldBegin("amount", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->amount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnIncrement &a, TColumnIncrement &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.amount, b.amount);
  swap(a.__isset, b.__isset);
}

TColumnIncrement::TColumnIncrement(const TColumnIncrement& other6) {
  family = other6.family;
  qualifier = other6.qualifier;
  amount = other6.amount;
  __isset = other6.__isset;
}
TColumnIncrement& TColumnIncrement::operator=(const TColumnIncrement& other7) {
  family = other7.family;
  qualifier = other7.qualifier;
  amount = other7.amount;
  __isset = other7.__isset;
  return *this;
}
void TColumnIncrement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnIncrement(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier=" << to_string(qualifier);
  out << ", " << "amount="; (__isset.amount ? (out << to_string(amount)) : (out << "<null>"));
  out << ")";
}


TResult::~TResult() noexcept {
}


void TResult::__set_row(const std::string& val) {
  this->row = val;
__isset.row = true;
}

void TResult::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TResult::__set_stale(const bool val) {
  this->stale = val;
__isset.stale = true;
}

void TResult::__set_partial(const bool val) {
  this->partial = val;
__isset.partial = true;
}
std::ostream& operator<<(std::ostream& out, const TResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          this->__isset.row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->columnValues.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->columnValues[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->stale);
          this->__isset.stale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->partial);
          this->__isset.partial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResult");

  if (this->__isset.row) {
    xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->row);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter13;
    for (_iter13 = this->columnValues.begin(); _iter13 != this->columnValues.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stale) {
    xfer += oprot->writeFieldBegin("stale", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->stale);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partial) {
    xfer += oprot->writeFieldBegin("partial", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->partial);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TResult &a, TResult &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.stale, b.stale);
  swap(a.partial, b.partial);
  swap(a.__isset, b.__isset);
}

TResult::TResult(const TResult& other14) {
  row = other14.row;
  columnValues = other14.columnValues;
  stale = other14.stale;
  partial = other14.partial;
  __isset = other14.__isset;
}
TResult& TResult::operator=(const TResult& other15) {
  row = other15.row;
  columnValues = other15.columnValues;
  stale = other15.stale;
  partial = other15.partial;
  __isset = other15.__isset;
  return *this;
}
void TResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResult(";
  out << "row="; (__isset.row ? (out << to_string(row)) : (out << "<null>"));
  out << ", " << "columnValues=" << to_string(columnValues);
  out << ", " << "stale="; (__isset.stale ? (out << to_string(stale)) : (out << "<null>"));
  out << ", " << "partial="; (__isset.partial ? (out << to_string(partial)) : (out << "<null>"));
  out << ")";
}


TAuthorization::~TAuthorization() noexcept {
}


void TAuthorization::__set_labels(const std::vector<std::string> & val) {
  this->labels = val;
__isset.labels = true;
}
std::ostream& operator<<(std::ostream& out, const TAuthorization& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAuthorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->labels.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readString(this->labels[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TAuthorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAuthorization");

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->labels.size()));
      std::vector<std::string> ::const_iterator _iter21;
      for (_iter21 = this->labels.begin(); _iter21 != this->labels.end(); ++_iter21)
      {
        xfer += oprot->writeString((*_iter21));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAuthorization &a, TAuthorization &b) {
  using ::std::swap;
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

TAuthorization::TAuthorization(const TAuthorization& other22) {
  labels = other22.labels;
  __isset = other22.__isset;
}
TAuthorization& TAuthorization::operator=(const TAuthorization& other23) {
  labels = other23.labels;
  __isset = other23.__isset;
  return *this;
}
void TAuthorization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAuthorization(";
  out << "labels="; (__isset.labels ? (out << to_string(labels)) : (out << "<null>"));
  out << ")";
}


TCellVisibility::~TCellVisibility() noexcept {
}


void TCellVisibility::__set_expression(const std::string& val) {
  this->expression = val;
__isset.expression = true;
}
std::ostream& operator<<(std::ostream& out, const TCellVisibility& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TCellVisibility::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expression);
          this->__isset.expression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TCellVisibility::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCellVisibility");

  if (this->__isset.expression) {
    xfer += oprot->writeFieldBegin("expression", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->expression);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TCellVisibility &a, TCellVisibility &b) {
  using ::std::swap;
  swap(a.expression, b.expression);
  swap(a.__isset, b.__isset);
}

TCellVisibility::TCellVisibility(const TCellVisibility& other24) {
  expression = other24.expression;
  __isset = other24.__isset;
}
TCellVisibility& TCellVisibility::operator=(const TCellVisibility& other25) {
  expression = other25.expression;
  __isset = other25.__isset;
  return *this;
}
void TCellVisibility::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCellVisibility(";
  out << "expression="; (__isset.expression ? (out << to_string(expression)) : (out << "<null>"));
  out << ")";
}


TGet::~TGet() noexcept {
}


void TGet::__set_row(const std::string& val) {
  this->row = val;
}

void TGet::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TGet::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TGet::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TGet::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TGet::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TGet::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TGet::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TGet::__set_consistency(const TConsistency::type val) {
  this->consistency = val;
__isset.consistency = true;
}

void TGet::__set_targetReplicaId(const int32_t val) {
  this->targetReplicaId = val;
__isset.targetReplicaId = true;
}

void TGet::__set_cacheBlocks(const bool val) {
  this->cacheBlocks = val;
__isset.cacheBlocks = true;
}

void TGet::__set_storeLimit(const int32_t val) {
  this->storeLimit = val;
__isset.storeLimit = true;
}

void TGet::__set_storeOffset(const int32_t val) {
  this->storeOffset = val;
__isset.storeOffset = true;
}

void TGet::__set_existence_only(const bool val) {
  this->existence_only = val;
__isset.existence_only = true;
}

void TGet::__set_filterBytes(const std::string& val) {
  this->filterBytes = val;
__isset.filterBytes = true;
}
std::ostream& operator<<(std::ostream& out, const TGet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TGet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->columns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->columns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _ktype32;
            ::apache::thrift::protocol::TType _vtype33;
            xfer += iprot->readMapBegin(_ktype32, _vtype33, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              std::string _key36;
              xfer += iprot->readBinary(_key36);
              std::string& _val37 = this->attributes[_key36];
              xfer += iprot->readBinary(_val37);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->consistency = static_cast<TConsistency::type>(ecast38);
          this->__isset.consistency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetReplicaId);
          this->__isset.targetReplicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBlocks);
          this->__isset.cacheBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->storeLimit);
          this->__isset.storeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->storeOffset);
          this->__isset.storeOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->existence_only);
          this->__isset.existence_only = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterBytes);
          this->__isset.filterBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TGet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGet");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter39;
      for (_iter39 = this->columns.begin(); _iter39 != this->columns.end(); ++_iter39)
      {
        xfer += (*_iter39).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter40;
      for (_iter40 = this->attributes.begin(); _iter40 != this->attributes.end(); ++_iter40)
      {
        xfer += oprot->writeBinary(_iter40->first);
        xfer += oprot->writeBinary(_iter40->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consistency) {
    xfer += oprot->writeFieldBegin("consistency", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(static_cast<int32_t>(this->consistency));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targetReplicaId) {
    xfer += oprot->writeFieldBegin("targetReplicaId", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->targetReplicaId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBlocks) {
    xfer += oprot->writeFieldBegin("cacheBlocks", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->cacheBlocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storeLimit) {
    xfer += oprot->writeFieldBegin("storeLimit", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->storeLimit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storeOffset) {
    xfer += oprot->writeFieldBegin("storeOffset", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->storeOffset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.existence_only) {
    xfer += oprot->writeFieldBegin("existence_only", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->existence_only);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterBytes) {
    xfer += oprot->writeFieldBegin("filterBytes", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeBinary(this->filterBytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TGet &a, TGet &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.timeRange, b.timeRange);
  swap(a.maxVersions, b.maxVersions);
  swap(a.filterString, b.filterString);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.consistency, b.consistency);
  swap(a.targetReplicaId, b.targetReplicaId);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.storeLimit, b.storeLimit);
  swap(a.storeOffset, b.storeOffset);
  swap(a.existence_only, b.existence_only);
  swap(a.filterBytes, b.filterBytes);
  swap(a.__isset, b.__isset);
}

TGet::TGet(const TGet& other41) {
  row = other41.row;
  columns = other41.columns;
  timestamp = other41.timestamp;
  timeRange = other41.timeRange;
  maxVersions = other41.maxVersions;
  filterString = other41.filterString;
  attributes = other41.attributes;
  authorizations = other41.authorizations;
  consistency = other41.consistency;
  targetReplicaId = other41.targetReplicaId;
  cacheBlocks = other41.cacheBlocks;
  storeLimit = other41.storeLimit;
  storeOffset = other41.storeOffset;
  existence_only = other41.existence_only;
  filterBytes = other41.filterBytes;
  __isset = other41.__isset;
}
TGet& TGet::operator=(const TGet& other42) {
  row = other42.row;
  columns = other42.columns;
  timestamp = other42.timestamp;
  timeRange = other42.timeRange;
  maxVersions = other42.maxVersions;
  filterString = other42.filterString;
  attributes = other42.attributes;
  authorizations = other42.authorizations;
  consistency = other42.consistency;
  targetReplicaId = other42.targetReplicaId;
  cacheBlocks = other42.cacheBlocks;
  storeLimit = other42.storeLimit;
  storeOffset = other42.storeOffset;
  existence_only = other42.existence_only;
  filterBytes = other42.filterBytes;
  __isset = other42.__isset;
  return *this;
}
void TGet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGet(";
  out << "row=" << to_string(row);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "timeRange="; (__isset.timeRange ? (out << to_string(timeRange)) : (out << "<null>"));
  out << ", " << "maxVersions="; (__isset.maxVersions ? (out << to_string(maxVersions)) : (out << "<null>"));
  out << ", " << "filterString="; (__isset.filterString ? (out << to_string(filterString)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "consistency="; (__isset.consistency ? (out << to_string(consistency)) : (out << "<null>"));
  out << ", " << "targetReplicaId="; (__isset.targetReplicaId ? (out << to_string(targetReplicaId)) : (out << "<null>"));
  out << ", " << "cacheBlocks="; (__isset.cacheBlocks ? (out << to_string(cacheBlocks)) : (out << "<null>"));
  out << ", " << "storeLimit="; (__isset.storeLimit ? (out << to_string(storeLimit)) : (out << "<null>"));
  out << ", " << "storeOffset="; (__isset.storeOffset ? (out << to_string(storeOffset)) : (out << "<null>"));
  out << ", " << "existence_only="; (__isset.existence_only ? (out << to_string(existence_only)) : (out << "<null>"));
  out << ", " << "filterBytes="; (__isset.filterBytes ? (out << to_string(filterBytes)) : (out << "<null>"));
  out << ")";
}


TPut::~TPut() noexcept {
}


void TPut::__set_row(const std::string& val) {
  this->row = val;
}

void TPut::__set_columnValues(const std::vector<TColumnValue> & val) {
  this->columnValues = val;
}

void TPut::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TPut::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TPut::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TPut::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}
std::ostream& operator<<(std::ostream& out, const TPut& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TPut::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columnValues = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnValues.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->columnValues.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->columnValues[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _ktype49;
            ::apache::thrift::protocol::TType _vtype50;
            xfer += iprot->readMapBegin(_ktype49, _vtype50, _size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              std::string _key53;
              xfer += iprot->readBinary(_key53);
              std::string& _val54 = this->attributes[_key53];
              xfer += iprot->readBinary(_val54);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->durability = static_cast<TDurability::type>(ecast55);
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnValues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TPut::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPut");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnValues", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnValues.size()));
    std::vector<TColumnValue> ::const_iterator _iter56;
    for (_iter56 = this->columnValues.begin(); _iter56 != this->columnValues.end(); ++_iter56)
    {
      xfer += (*_iter56).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter57;
      for (_iter57 = this->attributes.begin(); _iter57 != this->attributes.end(); ++_iter57)
      {
        xfer += oprot->writeBinary(_iter57->first);
        xfer += oprot->writeBinary(_iter57->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->durability));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TPut &a, TPut &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columnValues, b.columnValues);
  swap(a.timestamp, b.timestamp);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.__isset, b.__isset);
}

TPut::TPut(const TPut& other58) {
  row = other58.row;
  columnValues = other58.columnValues;
  timestamp = other58.timestamp;
  attributes = other58.attributes;
  durability = other58.durability;
  cellVisibility = other58.cellVisibility;
  __isset = other58.__isset;
}
TPut& TPut::operator=(const TPut& other59) {
  row = other59.row;
  columnValues = other59.columnValues;
  timestamp = other59.timestamp;
  attributes = other59.attributes;
  durability = other59.durability;
  cellVisibility = other59.cellVisibility;
  __isset = other59.__isset;
  return *this;
}
void TPut::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPut(";
  out << "row=" << to_string(row);
  out << ", " << "columnValues=" << to_string(columnValues);
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ")";
}


TDelete::~TDelete() noexcept {
}


void TDelete::__set_row(const std::string& val) {
  this->row = val;
}

void TDelete::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TDelete::__set_timestamp(const int64_t val) {
  this->timestamp = val;
__isset.timestamp = true;
}

void TDelete::__set_deleteType(const TDeleteType::type val) {
  this->deleteType = val;
__isset.deleteType = true;
}

void TDelete::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TDelete::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}
std::ostream& operator<<(std::ostream& out, const TDelete& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TDelete::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            xfer += iprot->readListBegin(_etype63, _size60);
            this->columns.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += this->columns[_i64].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->deleteType = static_cast<TDeleteType::type>(ecast65);
          this->__isset.deleteType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              std::string _key71;
              xfer += iprot->readBinary(_key71);
              std::string& _val72 = this->attributes[_key71];
              xfer += iprot->readBinary(_val72);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->durability = static_cast<TDurability::type>(ecast73);
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TDelete::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDelete");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter74;
      for (_iter74 = this->columns.begin(); _iter74 != this->columns.end(); ++_iter74)
      {
        xfer += (*_iter74).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteType) {
    xfer += oprot->writeFieldBegin("deleteType", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->deleteType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter75;
      for (_iter75 = this->attributes.begin(); _iter75 != this->attributes.end(); ++_iter75)
      {
        xfer += oprot->writeBinary(_iter75->first);
        xfer += oprot->writeBinary(_iter75->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->durability));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TDelete &a, TDelete &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.timestamp, b.timestamp);
  swap(a.deleteType, b.deleteType);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TDelete::TDelete(const TDelete& other76) {
  row = other76.row;
  columns = other76.columns;
  timestamp = other76.timestamp;
  deleteType = other76.deleteType;
  attributes = other76.attributes;
  durability = other76.durability;
  __isset = other76.__isset;
}
TDelete& TDelete::operator=(const TDelete& other77) {
  row = other77.row;
  columns = other77.columns;
  timestamp = other77.timestamp;
  deleteType = other77.deleteType;
  attributes = other77.attributes;
  durability = other77.durability;
  __isset = other77.__isset;
  return *this;
}
void TDelete::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDelete(";
  out << "row=" << to_string(row);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "timestamp="; (__isset.timestamp ? (out << to_string(timestamp)) : (out << "<null>"));
  out << ", " << "deleteType="; (__isset.deleteType ? (out << to_string(deleteType)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ")";
}


TIncrement::~TIncrement() noexcept {
}


void TIncrement::__set_row(const std::string& val) {
  this->row = val;
}

void TIncrement::__set_columns(const std::vector<TColumnIncrement> & val) {
  this->columns = val;
}

void TIncrement::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TIncrement::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TIncrement::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

void TIncrement::__set_returnResults(const bool val) {
  this->returnResults = val;
__isset.returnResults = true;
}
std::ostream& operator<<(std::ostream& out, const TIncrement& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIncrement::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->columns.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->columns[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _ktype84;
            ::apache::thrift::protocol::TType _vtype85;
            xfer += iprot->readMapBegin(_ktype84, _vtype85, _size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              std::string _key88;
              xfer += iprot->readBinary(_key88);
              std::string& _val89 = this->attributes[_key88];
              xfer += iprot->readBinary(_val89);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->durability = static_cast<TDurability::type>(ecast90);
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->returnResults);
          this->__isset.returnResults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TIncrement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIncrement");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnIncrement> ::const_iterator _iter91;
    for (_iter91 = this->columns.begin(); _iter91 != this->columns.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter92;
      for (_iter92 = this->attributes.begin(); _iter92 != this->attributes.end(); ++_iter92)
      {
        xfer += oprot->writeBinary(_iter92->first);
        xfer += oprot->writeBinary(_iter92->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->durability));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.returnResults) {
    xfer += oprot->writeFieldBegin("returnResults", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->returnResults);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIncrement &a, TIncrement &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.returnResults, b.returnResults);
  swap(a.__isset, b.__isset);
}

TIncrement::TIncrement(const TIncrement& other93) {
  row = other93.row;
  columns = other93.columns;
  attributes = other93.attributes;
  durability = other93.durability;
  cellVisibility = other93.cellVisibility;
  returnResults = other93.returnResults;
  __isset = other93.__isset;
}
TIncrement& TIncrement::operator=(const TIncrement& other94) {
  row = other94.row;
  columns = other94.columns;
  attributes = other94.attributes;
  durability = other94.durability;
  cellVisibility = other94.cellVisibility;
  returnResults = other94.returnResults;
  __isset = other94.__isset;
  return *this;
}
void TIncrement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIncrement(";
  out << "row=" << to_string(row);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ", " << "returnResults="; (__isset.returnResults ? (out << to_string(returnResults)) : (out << "<null>"));
  out << ")";
}


TAppend::~TAppend() noexcept {
}


void TAppend::__set_row(const std::string& val) {
  this->row = val;
}

void TAppend::__set_columns(const std::vector<TColumnValue> & val) {
  this->columns = val;
}

void TAppend::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TAppend::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}

void TAppend::__set_cellVisibility(const TCellVisibility& val) {
  this->cellVisibility = val;
__isset.cellVisibility = true;
}

void TAppend::__set_returnResults(const bool val) {
  this->returnResults = val;
__isset.returnResults = true;
}
std::ostream& operator<<(std::ostream& out, const TAppend& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TAppend::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->columns.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->columns[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _ktype101;
            ::apache::thrift::protocol::TType _vtype102;
            xfer += iprot->readMapBegin(_ktype101, _vtype102, _size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              std::string _key105;
              xfer += iprot->readBinary(_key105);
              std::string& _val106 = this->attributes[_key105];
              xfer += iprot->readBinary(_val106);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->durability = static_cast<TDurability::type>(ecast107);
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cellVisibility.read(iprot);
          this->__isset.cellVisibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->returnResults);
          this->__isset.returnResults = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TAppend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAppend");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<TColumnValue> ::const_iterator _iter108;
    for (_iter108 = this->columns.begin(); _iter108 != this->columns.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter109;
      for (_iter109 = this->attributes.begin(); _iter109 != this->attributes.end(); ++_iter109)
      {
        xfer += oprot->writeBinary(_iter109->first);
        xfer += oprot->writeBinary(_iter109->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->durability));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cellVisibility) {
    xfer += oprot->writeFieldBegin("cellVisibility", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->cellVisibility.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.returnResults) {
    xfer += oprot->writeFieldBegin("returnResults", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->returnResults);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TAppend &a, TAppend &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.cellVisibility, b.cellVisibility);
  swap(a.returnResults, b.returnResults);
  swap(a.__isset, b.__isset);
}

TAppend::TAppend(const TAppend& other110) {
  row = other110.row;
  columns = other110.columns;
  attributes = other110.attributes;
  durability = other110.durability;
  cellVisibility = other110.cellVisibility;
  returnResults = other110.returnResults;
  __isset = other110.__isset;
}
TAppend& TAppend::operator=(const TAppend& other111) {
  row = other111.row;
  columns = other111.columns;
  attributes = other111.attributes;
  durability = other111.durability;
  cellVisibility = other111.cellVisibility;
  returnResults = other111.returnResults;
  __isset = other111.__isset;
  return *this;
}
void TAppend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAppend(";
  out << "row=" << to_string(row);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ", " << "cellVisibility="; (__isset.cellVisibility ? (out << to_string(cellVisibility)) : (out << "<null>"));
  out << ", " << "returnResults="; (__isset.returnResults ? (out << to_string(returnResults)) : (out << "<null>"));
  out << ")";
}


TScan::~TScan() noexcept {
}


void TScan::__set_startRow(const std::string& val) {
  this->startRow = val;
__isset.startRow = true;
}

void TScan::__set_stopRow(const std::string& val) {
  this->stopRow = val;
__isset.stopRow = true;
}

void TScan::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TScan::__set_caching(const int32_t val) {
  this->caching = val;
__isset.caching = true;
}

void TScan::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TScan::__set_timeRange(const TTimeRange& val) {
  this->timeRange = val;
__isset.timeRange = true;
}

void TScan::__set_filterString(const std::string& val) {
  this->filterString = val;
__isset.filterString = true;
}

void TScan::__set_batchSize(const int32_t val) {
  this->batchSize = val;
__isset.batchSize = true;
}

void TScan::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TScan::__set_authorizations(const TAuthorization& val) {
  this->authorizations = val;
__isset.authorizations = true;
}

void TScan::__set_reversed(const bool val) {
  this->reversed = val;
__isset.reversed = true;
}

void TScan::__set_cacheBlocks(const bool val) {
  this->cacheBlocks = val;
__isset.cacheBlocks = true;
}

void TScan::__set_colFamTimeRangeMap(const std::map<std::string, TTimeRange> & val) {
  this->colFamTimeRangeMap = val;
__isset.colFamTimeRangeMap = true;
}

void TScan::__set_readType(const TReadType::type val) {
  this->readType = val;
__isset.readType = true;
}

void TScan::__set_limit(const int32_t val) {
  this->limit = val;
__isset.limit = true;
}

void TScan::__set_consistency(const TConsistency::type val) {
  this->consistency = val;
__isset.consistency = true;
}

void TScan::__set_targetReplicaId(const int32_t val) {
  this->targetReplicaId = val;
__isset.targetReplicaId = true;
}

void TScan::__set_filterBytes(const std::string& val) {
  this->filterBytes = val;
__isset.filterBytes = true;
}
std::ostream& operator<<(std::ostream& out, const TScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startRow);
          this->__isset.startRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->stopRow);
          this->__isset.stopRow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->columns.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->columns[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeRange.read(iprot);
          this->__isset.timeRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterString);
          this->__isset.filterString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchSize);
          this->__isset.batchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size117;
            ::apache::thrift::protocol::TType _ktype118;
            ::apache::thrift::protocol::TType _vtype119;
            xfer += iprot->readMapBegin(_ktype118, _vtype119, _size117);
            uint32_t _i121;
            for (_i121 = 0; _i121 < _size117; ++_i121)
            {
              std::string _key122;
              xfer += iprot->readBinary(_key122);
              std::string& _val123 = this->attributes[_key122];
              xfer += iprot->readBinary(_val123);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorizations.read(iprot);
          this->__isset.authorizations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          this->__isset.reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBlocks);
          this->__isset.cacheBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->colFamTimeRangeMap.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readBinary(_key129);
              TTimeRange& _val130 = this->colFamTimeRangeMap[_key129];
              xfer += _val130.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.colFamTimeRangeMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast131;
          xfer += iprot->readI32(ecast131);
          this->readType = static_cast<TReadType::type>(ecast131);
          this->__isset.readType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->consistency = static_cast<TConsistency::type>(ecast132);
          this->__isset.consistency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetReplicaId);
          this->__isset.targetReplicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->filterBytes);
          this->__isset.filterBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScan");

  if (this->__isset.startRow) {
    xfer += oprot->writeFieldBegin("startRow", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->startRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopRow) {
    xfer += oprot->writeFieldBegin("stopRow", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->stopRow);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter133;
      for (_iter133 = this->columns.begin(); _iter133 != this->columns.end(); ++_iter133)
      {
        xfer += (*_iter133).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeRange) {
    xfer += oprot->writeFieldBegin("timeRange", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->timeRange.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterString) {
    xfer += oprot->writeFieldBegin("filterString", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeBinary(this->filterString);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchSize) {
    xfer += oprot->writeFieldBegin("batchSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->batchSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter134;
      for (_iter134 = this->attributes.begin(); _iter134 != this->attributes.end(); ++_iter134)
      {
        xfer += oprot->writeBinary(_iter134->first);
        xfer += oprot->writeBinary(_iter134->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authorizations) {
    xfer += oprot->writeFieldBegin("authorizations", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->authorizations.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reversed) {
    xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->reversed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBlocks) {
    xfer += oprot->writeFieldBegin("cacheBlocks", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cacheBlocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.colFamTimeRangeMap) {
    xfer += oprot->writeFieldBegin("colFamTimeRangeMap", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->colFamTimeRangeMap.size()));
      std::map<std::string, TTimeRange> ::const_iterator _iter135;
      for (_iter135 = this->colFamTimeRangeMap.begin(); _iter135 != this->colFamTimeRangeMap.end(); ++_iter135)
      {
        xfer += oprot->writeBinary(_iter135->first);
        xfer += _iter135->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readType) {
    xfer += oprot->writeFieldBegin("readType", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(static_cast<int32_t>(this->readType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consistency) {
    xfer += oprot->writeFieldBegin("consistency", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(static_cast<int32_t>(this->consistency));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targetReplicaId) {
    xfer += oprot->writeFieldBegin("targetReplicaId", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->targetReplicaId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filterBytes) {
    xfer += oprot->writeFieldBegin("filterBytes", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeBinary(this->filterBytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TScan &a, TScan &b) {
  using ::std::swap;
  swap(a.startRow, b.startRow);
  swap(a.stopRow, b.stopRow);
  swap(a.columns, b.columns);
  swap(a.caching, b.caching);
  swap(a.maxVersions, b.maxVersions);
  swap(a.timeRange, b.timeRange);
  swap(a.filterString, b.filterString);
  swap(a.batchSize, b.batchSize);
  swap(a.attributes, b.attributes);
  swap(a.authorizations, b.authorizations);
  swap(a.reversed, b.reversed);
  swap(a.cacheBlocks, b.cacheBlocks);
  swap(a.colFamTimeRangeMap, b.colFamTimeRangeMap);
  swap(a.readType, b.readType);
  swap(a.limit, b.limit);
  swap(a.consistency, b.consistency);
  swap(a.targetReplicaId, b.targetReplicaId);
  swap(a.filterBytes, b.filterBytes);
  swap(a.__isset, b.__isset);
}

TScan::TScan(const TScan& other136) {
  startRow = other136.startRow;
  stopRow = other136.stopRow;
  columns = other136.columns;
  caching = other136.caching;
  maxVersions = other136.maxVersions;
  timeRange = other136.timeRange;
  filterString = other136.filterString;
  batchSize = other136.batchSize;
  attributes = other136.attributes;
  authorizations = other136.authorizations;
  reversed = other136.reversed;
  cacheBlocks = other136.cacheBlocks;
  colFamTimeRangeMap = other136.colFamTimeRangeMap;
  readType = other136.readType;
  limit = other136.limit;
  consistency = other136.consistency;
  targetReplicaId = other136.targetReplicaId;
  filterBytes = other136.filterBytes;
  __isset = other136.__isset;
}
TScan& TScan::operator=(const TScan& other137) {
  startRow = other137.startRow;
  stopRow = other137.stopRow;
  columns = other137.columns;
  caching = other137.caching;
  maxVersions = other137.maxVersions;
  timeRange = other137.timeRange;
  filterString = other137.filterString;
  batchSize = other137.batchSize;
  attributes = other137.attributes;
  authorizations = other137.authorizations;
  reversed = other137.reversed;
  cacheBlocks = other137.cacheBlocks;
  colFamTimeRangeMap = other137.colFamTimeRangeMap;
  readType = other137.readType;
  limit = other137.limit;
  consistency = other137.consistency;
  targetReplicaId = other137.targetReplicaId;
  filterBytes = other137.filterBytes;
  __isset = other137.__isset;
  return *this;
}
void TScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScan(";
  out << "startRow="; (__isset.startRow ? (out << to_string(startRow)) : (out << "<null>"));
  out << ", " << "stopRow="; (__isset.stopRow ? (out << to_string(stopRow)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "caching="; (__isset.caching ? (out << to_string(caching)) : (out << "<null>"));
  out << ", " << "maxVersions="; (__isset.maxVersions ? (out << to_string(maxVersions)) : (out << "<null>"));
  out << ", " << "timeRange="; (__isset.timeRange ? (out << to_string(timeRange)) : (out << "<null>"));
  out << ", " << "filterString="; (__isset.filterString ? (out << to_string(filterString)) : (out << "<null>"));
  out << ", " << "batchSize="; (__isset.batchSize ? (out << to_string(batchSize)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "authorizations="; (__isset.authorizations ? (out << to_string(authorizations)) : (out << "<null>"));
  out << ", " << "reversed="; (__isset.reversed ? (out << to_string(reversed)) : (out << "<null>"));
  out << ", " << "cacheBlocks="; (__isset.cacheBlocks ? (out << to_string(cacheBlocks)) : (out << "<null>"));
  out << ", " << "colFamTimeRangeMap="; (__isset.colFamTimeRangeMap ? (out << to_string(colFamTimeRangeMap)) : (out << "<null>"));
  out << ", " << "readType="; (__isset.readType ? (out << to_string(readType)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "consistency="; (__isset.consistency ? (out << to_string(consistency)) : (out << "<null>"));
  out << ", " << "targetReplicaId="; (__isset.targetReplicaId ? (out << to_string(targetReplicaId)) : (out << "<null>"));
  out << ", " << "filterBytes="; (__isset.filterBytes ? (out << to_string(filterBytes)) : (out << "<null>"));
  out << ")";
}


TMutation::~TMutation() noexcept {
}


void TMutation::__set_put(const TPut& val) {
  this->put = val;
__isset.put = true;
}

void TMutation::__set_deleteSingle(const TDelete& val) {
  this->deleteSingle = val;
__isset.deleteSingle = true;
}
std::ostream& operator<<(std::ostream& out, const TMutation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TMutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->put.read(iprot);
          this->__isset.put = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deleteSingle.read(iprot);
          this->__isset.deleteSingle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TMutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMutation");

  if (this->__isset.put) {
    xfer += oprot->writeFieldBegin("put", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->put.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleteSingle) {
    xfer += oprot->writeFieldBegin("deleteSingle", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->deleteSingle.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TMutation &a, TMutation &b) {
  using ::std::swap;
  swap(a.put, b.put);
  swap(a.deleteSingle, b.deleteSingle);
  swap(a.__isset, b.__isset);
}

TMutation::TMutation(const TMutation& other138) {
  put = other138.put;
  deleteSingle = other138.deleteSingle;
  __isset = other138.__isset;
}
TMutation& TMutation::operator=(const TMutation& other139) {
  put = other139.put;
  deleteSingle = other139.deleteSingle;
  __isset = other139.__isset;
  return *this;
}
void TMutation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TMutation(";
  out << "put="; (__isset.put ? (out << to_string(put)) : (out << "<null>"));
  out << ", " << "deleteSingle="; (__isset.deleteSingle ? (out << to_string(deleteSingle)) : (out << "<null>"));
  out << ")";
}


TRowMutations::~TRowMutations() noexcept {
}


void TRowMutations::__set_row(const std::string& val) {
  this->row = val;
}

void TRowMutations::__set_mutations(const std::vector<TMutation> & val) {
  this->mutations = val;
}
std::ostream& operator<<(std::ostream& out, const TRowMutations& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TRowMutations::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row = false;
  bool isset_mutations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->row);
          isset_row = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mutations.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->mutations.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->mutations[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_mutations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mutations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TRowMutations::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRowMutations");

  xfer += oprot->writeFieldBegin("row", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->row);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mutations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mutations.size()));
    std::vector<TMutation> ::const_iterator _iter145;
    for (_iter145 = this->mutations.begin(); _iter145 != this->mutations.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TRowMutations &a, TRowMutations &b) {
  using ::std::swap;
  swap(a.row, b.row);
  swap(a.mutations, b.mutations);
}

TRowMutations::TRowMutations(const TRowMutations& other146) {
  row = other146.row;
  mutations = other146.mutations;
}
TRowMutations& TRowMutations::operator=(const TRowMutations& other147) {
  row = other147.row;
  mutations = other147.mutations;
  return *this;
}
void TRowMutations::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowMutations(";
  out << "row=" << to_string(row);
  out << ", " << "mutations=" << to_string(mutations);
  out << ")";
}


THRegionInfo::~THRegionInfo() noexcept {
}


void THRegionInfo::__set_regionId(const int64_t val) {
  this->regionId = val;
}

void THRegionInfo::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void THRegionInfo::__set_startKey(const std::string& val) {
  this->startKey = val;
__isset.startKey = true;
}

void THRegionInfo::__set_endKey(const std::string& val) {
  this->endKey = val;
__isset.endKey = true;
}

void THRegionInfo::__set_offline(const bool val) {
  this->offline = val;
__isset.offline = true;
}

void THRegionInfo::__set_split(const bool val) {
  this->split = val;
__isset.split = true;
}

void THRegionInfo::__set_replicaId(const int32_t val) {
  this->replicaId = val;
__isset.replicaId = true;
}
std::ostream& operator<<(std::ostream& out, const THRegionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRegionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_regionId = false;
  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->regionId);
          isset_regionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offline);
          this->__isset.offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->split);
          this->__isset.split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replicaId);
          this->__isset.replicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_regionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRegionInfo");

  xfer += oprot->writeFieldBegin("regionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->regionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.startKey) {
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endKey) {
    xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->endKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline) {
    xfer += oprot->writeFieldBegin("offline", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.split) {
    xfer += oprot->writeFieldBegin("split", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->split);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaId) {
    xfer += oprot->writeFieldBegin("replicaId", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->replicaId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRegionInfo &a, THRegionInfo &b) {
  using ::std::swap;
  swap(a.regionId, b.regionId);
  swap(a.tableName, b.tableName);
  swap(a.startKey, b.startKey);
  swap(a.endKey, b.endKey);
  swap(a.offline, b.offline);
  swap(a.split, b.split);
  swap(a.replicaId, b.replicaId);
  swap(a.__isset, b.__isset);
}

THRegionInfo::THRegionInfo(const THRegionInfo& other148) {
  regionId = other148.regionId;
  tableName = other148.tableName;
  startKey = other148.startKey;
  endKey = other148.endKey;
  offline = other148.offline;
  split = other148.split;
  replicaId = other148.replicaId;
  __isset = other148.__isset;
}
THRegionInfo& THRegionInfo::operator=(const THRegionInfo& other149) {
  regionId = other149.regionId;
  tableName = other149.tableName;
  startKey = other149.startKey;
  endKey = other149.endKey;
  offline = other149.offline;
  split = other149.split;
  replicaId = other149.replicaId;
  __isset = other149.__isset;
  return *this;
}
void THRegionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRegionInfo(";
  out << "regionId=" << to_string(regionId);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "startKey="; (__isset.startKey ? (out << to_string(startKey)) : (out << "<null>"));
  out << ", " << "endKey="; (__isset.endKey ? (out << to_string(endKey)) : (out << "<null>"));
  out << ", " << "offline="; (__isset.offline ? (out << to_string(offline)) : (out << "<null>"));
  out << ", " << "split="; (__isset.split ? (out << to_string(split)) : (out << "<null>"));
  out << ", " << "replicaId="; (__isset.replicaId ? (out << to_string(replicaId)) : (out << "<null>"));
  out << ")";
}


TServerName::~TServerName() noexcept {
}


void TServerName::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void TServerName::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void TServerName::__set_startCode(const int64_t val) {
  this->startCode = val;
__isset.startCode = true;
}
std::ostream& operator<<(std::ostream& out, const TServerName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TServerName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startCode);
          this->__isset.startCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TServerName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TServerName");

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.startCode) {
    xfer += oprot->writeFieldBegin("startCode", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->startCode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TServerName &a, TServerName &b) {
  using ::std::swap;
  swap(a.hostName, b.hostName);
  swap(a.port, b.port);
  swap(a.startCode, b.startCode);
  swap(a.__isset, b.__isset);
}

TServerName::TServerName(const TServerName& other150) {
  hostName = other150.hostName;
  port = other150.port;
  startCode = other150.startCode;
  __isset = other150.__isset;
}
TServerName& TServerName::operator=(const TServerName& other151) {
  hostName = other151.hostName;
  port = other151.port;
  startCode = other151.startCode;
  __isset = other151.__isset;
  return *this;
}
void TServerName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TServerName(";
  out << "hostName=" << to_string(hostName);
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "startCode="; (__isset.startCode ? (out << to_string(startCode)) : (out << "<null>"));
  out << ")";
}


THRegionLocation::~THRegionLocation() noexcept {
}


void THRegionLocation::__set_serverName(const TServerName& val) {
  this->serverName = val;
}

void THRegionLocation::__set_regionInfo(const THRegionInfo& val) {
  this->regionInfo = val;
}
std::ostream& operator<<(std::ostream& out, const THRegionLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRegionLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_serverName = false;
  bool isset_regionInfo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverName.read(iprot);
          isset_serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->regionInfo.read(iprot);
          isset_regionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_serverName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_regionInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t THRegionLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRegionLocation");

  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->serverName.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regionInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->regionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRegionLocation &a, THRegionLocation &b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.regionInfo, b.regionInfo);
}

THRegionLocation::THRegionLocation(const THRegionLocation& other152) {
  serverName = other152.serverName;
  regionInfo = other152.regionInfo;
}
THRegionLocation& THRegionLocation::operator=(const THRegionLocation& other153) {
  serverName = other153.serverName;
  regionInfo = other153.regionInfo;
  return *this;
}
void THRegionLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRegionLocation(";
  out << "serverName=" << to_string(serverName);
  out << ", " << "regionInfo=" << to_string(regionInfo);
  out << ")";
}


TTableName::~TTableName() noexcept {
}


void TTableName::__set_ns(const std::string& val) {
  this->ns = val;
__isset.ns = true;
}

void TTableName::__set_qualifier(const std::string& val) {
  this->qualifier = val;
}
std::ostream& operator<<(std::ostream& out, const TTableName& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableName::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_qualifier = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->qualifier);
          isset_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_qualifier)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableName");

  if (this->__isset.ns) {
    xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->qualifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.ns, b.ns);
  swap(a.qualifier, b.qualifier);
  swap(a.__isset, b.__isset);
}

TTableName::TTableName(const TTableName& other154) {
  ns = other154.ns;
  qualifier = other154.qualifier;
  __isset = other154.__isset;
}
TTableName& TTableName::operator=(const TTableName& other155) {
  ns = other155.ns;
  qualifier = other155.qualifier;
  __isset = other155.__isset;
  return *this;
}
void TTableName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableName(";
  out << "ns="; (__isset.ns ? (out << to_string(ns)) : (out << "<null>"));
  out << ", " << "qualifier=" << to_string(qualifier);
  out << ")";
}


TColumnFamilyDescriptor::~TColumnFamilyDescriptor() noexcept {
}


void TColumnFamilyDescriptor::__set_name(const std::string& val) {
  this->name = val;
}

void TColumnFamilyDescriptor::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TColumnFamilyDescriptor::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}

void TColumnFamilyDescriptor::__set_blockSize(const int32_t val) {
  this->blockSize = val;
__isset.blockSize = true;
}

void TColumnFamilyDescriptor::__set_bloomnFilterType(const TBloomFilterType::type val) {
  this->bloomnFilterType = val;
__isset.bloomnFilterType = true;
}

void TColumnFamilyDescriptor::__set_compressionType(const TCompressionAlgorithm::type val) {
  this->compressionType = val;
__isset.compressionType = true;
}

void TColumnFamilyDescriptor::__set_dfsReplication(const int16_t val) {
  this->dfsReplication = val;
__isset.dfsReplication = true;
}

void TColumnFamilyDescriptor::__set_dataBlockEncoding(const TDataBlockEncoding::type val) {
  this->dataBlockEncoding = val;
__isset.dataBlockEncoding = true;
}

void TColumnFamilyDescriptor::__set_keepDeletedCells(const TKeepDeletedCells::type val) {
  this->keepDeletedCells = val;
__isset.keepDeletedCells = true;
}

void TColumnFamilyDescriptor::__set_maxVersions(const int32_t val) {
  this->maxVersions = val;
__isset.maxVersions = true;
}

void TColumnFamilyDescriptor::__set_minVersions(const int32_t val) {
  this->minVersions = val;
__isset.minVersions = true;
}

void TColumnFamilyDescriptor::__set_scope(const int32_t val) {
  this->scope = val;
__isset.scope = true;
}

void TColumnFamilyDescriptor::__set_timeToLive(const int32_t val) {
  this->timeToLive = val;
__isset.timeToLive = true;
}

void TColumnFamilyDescriptor::__set_blockCacheEnabled(const bool val) {
  this->blockCacheEnabled = val;
__isset.blockCacheEnabled = true;
}

void TColumnFamilyDescriptor::__set_cacheBloomsOnWrite(const bool val) {
  this->cacheBloomsOnWrite = val;
__isset.cacheBloomsOnWrite = true;
}

void TColumnFamilyDescriptor::__set_cacheDataOnWrite(const bool val) {
  this->cacheDataOnWrite = val;
__isset.cacheDataOnWrite = true;
}

void TColumnFamilyDescriptor::__set_cacheIndexesOnWrite(const bool val) {
  this->cacheIndexesOnWrite = val;
__isset.cacheIndexesOnWrite = true;
}

void TColumnFamilyDescriptor::__set_compressTags(const bool val) {
  this->compressTags = val;
__isset.compressTags = true;
}

void TColumnFamilyDescriptor::__set_evictBlocksOnClose(const bool val) {
  this->evictBlocksOnClose = val;
__isset.evictBlocksOnClose = true;
}

void TColumnFamilyDescriptor::__set_inMemory(const bool val) {
  this->inMemory = val;
__isset.inMemory = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnFamilyDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TColumnFamilyDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _ktype157;
            ::apache::thrift::protocol::TType _vtype158;
            xfer += iprot->readMapBegin(_ktype157, _vtype158, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              std::string _key161;
              xfer += iprot->readBinary(_key161);
              std::string& _val162 = this->attributes[_key161];
              xfer += iprot->readBinary(_val162);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size163;
            ::apache::thrift::protocol::TType _ktype164;
            ::apache::thrift::protocol::TType _vtype165;
            xfer += iprot->readMapBegin(_ktype164, _vtype165, _size163);
            uint32_t _i167;
            for (_i167 = 0; _i167 < _size163; ++_i167)
            {
              std::string _key168;
              xfer += iprot->readString(_key168);
              std::string& _val169 = this->configuration[_key168];
              xfer += iprot->readString(_val169);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockSize);
          this->__isset.blockSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast170;
          xfer += iprot->readI32(ecast170);
          this->bloomnFilterType = static_cast<TBloomFilterType::type>(ecast170);
          this->__isset.bloomnFilterType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->compressionType = static_cast<TCompressionAlgorithm::type>(ecast171);
          this->__isset.compressionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->dfsReplication);
          this->__isset.dfsReplication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->dataBlockEncoding = static_cast<TDataBlockEncoding::type>(ecast172);
          this->__isset.dataBlockEncoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast173;
          xfer += iprot->readI32(ecast173);
          this->keepDeletedCells = static_cast<TKeepDeletedCells::type>(ecast173);
          this->__isset.keepDeletedCells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxVersions);
          this->__isset.maxVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minVersions);
          this->__isset.minVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeToLive);
          this->__isset.timeToLive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->blockCacheEnabled);
          this->__isset.blockCacheEnabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheBloomsOnWrite);
          this->__isset.cacheBloomsOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheDataOnWrite);
          this->__isset.cacheDataOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cacheIndexesOnWrite);
          this->__isset.cacheIndexesOnWrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressTags);
          this->__isset.compressTags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->evictBlocksOnClose);
          this->__isset.evictBlocksOnClose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->inMemory);
          this->__isset.inMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TColumnFamilyDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnFamilyDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter174;
      for (_iter174 = this->attributes.begin(); _iter174 != this->attributes.end(); ++_iter174)
      {
        xfer += oprot->writeBinary(_iter174->first);
        xfer += oprot->writeBinary(_iter174->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter175;
      for (_iter175 = this->configuration.begin(); _iter175 != this->configuration.end(); ++_iter175)
      {
        xfer += oprot->writeString(_iter175->first);
        xfer += oprot->writeString(_iter175->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockSize) {
    xfer += oprot->writeFieldBegin("blockSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->blockSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloomnFilterType) {
    xfer += oprot->writeFieldBegin("bloomnFilterType", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->bloomnFilterType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressionType) {
    xfer += oprot->writeFieldBegin("compressionType", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->compressionType));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dfsReplication) {
    xfer += oprot->writeFieldBegin("dfsReplication", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->dfsReplication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataBlockEncoding) {
    xfer += oprot->writeFieldBegin("dataBlockEncoding", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(static_cast<int32_t>(this->dataBlockEncoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keepDeletedCells) {
    xfer += oprot->writeFieldBegin("keepDeletedCells", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(static_cast<int32_t>(this->keepDeletedCells));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxVersions) {
    xfer += oprot->writeFieldBegin("maxVersions", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->maxVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minVersions) {
    xfer += oprot->writeFieldBegin("minVersions", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->minVersions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scope) {
    xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->scope);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeToLive) {
    xfer += oprot->writeFieldBegin("timeToLive", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->timeToLive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blockCacheEnabled) {
    xfer += oprot->writeFieldBegin("blockCacheEnabled", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->blockCacheEnabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheBloomsOnWrite) {
    xfer += oprot->writeFieldBegin("cacheBloomsOnWrite", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->cacheBloomsOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheDataOnWrite) {
    xfer += oprot->writeFieldBegin("cacheDataOnWrite", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->cacheDataOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cacheIndexesOnWrite) {
    xfer += oprot->writeFieldBegin("cacheIndexesOnWrite", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->cacheIndexesOnWrite);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressTags) {
    xfer += oprot->writeFieldBegin("compressTags", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->compressTags);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.evictBlocksOnClose) {
    xfer += oprot->writeFieldBegin("evictBlocksOnClose", ::apache::thrift::protocol::T_BOOL, 19);
    xfer += oprot->writeBool(this->evictBlocksOnClose);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inMemory) {
    xfer += oprot->writeFieldBegin("inMemory", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->inMemory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TColumnFamilyDescriptor &a, TColumnFamilyDescriptor &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.attributes, b.attributes);
  swap(a.configuration, b.configuration);
  swap(a.blockSize, b.blockSize);
  swap(a.bloomnFilterType, b.bloomnFilterType);
  swap(a.compressionType, b.compressionType);
  swap(a.dfsReplication, b.dfsReplication);
  swap(a.dataBlockEncoding, b.dataBlockEncoding);
  swap(a.keepDeletedCells, b.keepDeletedCells);
  swap(a.maxVersions, b.maxVersions);
  swap(a.minVersions, b.minVersions);
  swap(a.scope, b.scope);
  swap(a.timeToLive, b.timeToLive);
  swap(a.blockCacheEnabled, b.blockCacheEnabled);
  swap(a.cacheBloomsOnWrite, b.cacheBloomsOnWrite);
  swap(a.cacheDataOnWrite, b.cacheDataOnWrite);
  swap(a.cacheIndexesOnWrite, b.cacheIndexesOnWrite);
  swap(a.compressTags, b.compressTags);
  swap(a.evictBlocksOnClose, b.evictBlocksOnClose);
  swap(a.inMemory, b.inMemory);
  swap(a.__isset, b.__isset);
}

TColumnFamilyDescriptor::TColumnFamilyDescriptor(const TColumnFamilyDescriptor& other176) {
  name = other176.name;
  attributes = other176.attributes;
  configuration = other176.configuration;
  blockSize = other176.blockSize;
  bloomnFilterType = other176.bloomnFilterType;
  compressionType = other176.compressionType;
  dfsReplication = other176.dfsReplication;
  dataBlockEncoding = other176.dataBlockEncoding;
  keepDeletedCells = other176.keepDeletedCells;
  maxVersions = other176.maxVersions;
  minVersions = other176.minVersions;
  scope = other176.scope;
  timeToLive = other176.timeToLive;
  blockCacheEnabled = other176.blockCacheEnabled;
  cacheBloomsOnWrite = other176.cacheBloomsOnWrite;
  cacheDataOnWrite = other176.cacheDataOnWrite;
  cacheIndexesOnWrite = other176.cacheIndexesOnWrite;
  compressTags = other176.compressTags;
  evictBlocksOnClose = other176.evictBlocksOnClose;
  inMemory = other176.inMemory;
  __isset = other176.__isset;
}
TColumnFamilyDescriptor& TColumnFamilyDescriptor::operator=(const TColumnFamilyDescriptor& other177) {
  name = other177.name;
  attributes = other177.attributes;
  configuration = other177.configuration;
  blockSize = other177.blockSize;
  bloomnFilterType = other177.bloomnFilterType;
  compressionType = other177.compressionType;
  dfsReplication = other177.dfsReplication;
  dataBlockEncoding = other177.dataBlockEncoding;
  keepDeletedCells = other177.keepDeletedCells;
  maxVersions = other177.maxVersions;
  minVersions = other177.minVersions;
  scope = other177.scope;
  timeToLive = other177.timeToLive;
  blockCacheEnabled = other177.blockCacheEnabled;
  cacheBloomsOnWrite = other177.cacheBloomsOnWrite;
  cacheDataOnWrite = other177.cacheDataOnWrite;
  cacheIndexesOnWrite = other177.cacheIndexesOnWrite;
  compressTags = other177.compressTags;
  evictBlocksOnClose = other177.evictBlocksOnClose;
  inMemory = other177.inMemory;
  __isset = other177.__isset;
  return *this;
}
void TColumnFamilyDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnFamilyDescriptor(";
  out << "name=" << to_string(name);
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ", " << "blockSize="; (__isset.blockSize ? (out << to_string(blockSize)) : (out << "<null>"));
  out << ", " << "bloomnFilterType="; (__isset.bloomnFilterType ? (out << to_string(bloomnFilterType)) : (out << "<null>"));
  out << ", " << "compressionType="; (__isset.compressionType ? (out << to_string(compressionType)) : (out << "<null>"));
  out << ", " << "dfsReplication="; (__isset.dfsReplication ? (out << to_string(dfsReplication)) : (out << "<null>"));
  out << ", " << "dataBlockEncoding="; (__isset.dataBlockEncoding ? (out << to_string(dataBlockEncoding)) : (out << "<null>"));
  out << ", " << "keepDeletedCells="; (__isset.keepDeletedCells ? (out << to_string(keepDeletedCells)) : (out << "<null>"));
  out << ", " << "maxVersions="; (__isset.maxVersions ? (out << to_string(maxVersions)) : (out << "<null>"));
  out << ", " << "minVersions="; (__isset.minVersions ? (out << to_string(minVersions)) : (out << "<null>"));
  out << ", " << "scope="; (__isset.scope ? (out << to_string(scope)) : (out << "<null>"));
  out << ", " << "timeToLive="; (__isset.timeToLive ? (out << to_string(timeToLive)) : (out << "<null>"));
  out << ", " << "blockCacheEnabled="; (__isset.blockCacheEnabled ? (out << to_string(blockCacheEnabled)) : (out << "<null>"));
  out << ", " << "cacheBloomsOnWrite="; (__isset.cacheBloomsOnWrite ? (out << to_string(cacheBloomsOnWrite)) : (out << "<null>"));
  out << ", " << "cacheDataOnWrite="; (__isset.cacheDataOnWrite ? (out << to_string(cacheDataOnWrite)) : (out << "<null>"));
  out << ", " << "cacheIndexesOnWrite="; (__isset.cacheIndexesOnWrite ? (out << to_string(cacheIndexesOnWrite)) : (out << "<null>"));
  out << ", " << "compressTags="; (__isset.compressTags ? (out << to_string(compressTags)) : (out << "<null>"));
  out << ", " << "evictBlocksOnClose="; (__isset.evictBlocksOnClose ? (out << to_string(evictBlocksOnClose)) : (out << "<null>"));
  out << ", " << "inMemory="; (__isset.inMemory ? (out << to_string(inMemory)) : (out << "<null>"));
  out << ")";
}


TTableDescriptor::~TTableDescriptor() noexcept {
}


void TTableDescriptor::__set_tableName(const TTableName& val) {
  this->tableName = val;
}

void TTableDescriptor::__set_columns(const std::vector<TColumnFamilyDescriptor> & val) {
  this->columns = val;
__isset.columns = true;
}

void TTableDescriptor::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TTableDescriptor::__set_durability(const TDurability::type val) {
  this->durability = val;
__isset.durability = true;
}
std::ostream& operator<<(std::ostream& out, const TTableDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TTableDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tableName.read(iprot);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->columns.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += this->columns[_i182].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size183;
            ::apache::thrift::protocol::TType _ktype184;
            ::apache::thrift::protocol::TType _vtype185;
            xfer += iprot->readMapBegin(_ktype184, _vtype185, _size183);
            uint32_t _i187;
            for (_i187 = 0; _i187 < _size183; ++_i187)
            {
              std::string _key188;
              xfer += iprot->readBinary(_key188);
              std::string& _val189 = this->attributes[_key188];
              xfer += iprot->readBinary(_val189);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast190;
          xfer += iprot->readI32(ecast190);
          this->durability = static_cast<TDurability::type>(ecast190);
          this->__isset.durability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TTableDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDescriptor");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tableName.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumnFamilyDescriptor> ::const_iterator _iter191;
      for (_iter191 = this->columns.begin(); _iter191 != this->columns.end(); ++_iter191)
      {
        xfer += (*_iter191).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter192;
      for (_iter192 = this->attributes.begin(); _iter192 != this->attributes.end(); ++_iter192)
      {
        xfer += oprot->writeBinary(_iter192->first);
        xfer += oprot->writeBinary(_iter192->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.durability) {
    xfer += oprot->writeFieldBegin("durability", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->durability));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TTableDescriptor &a, TTableDescriptor &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.columns, b.columns);
  swap(a.attributes, b.attributes);
  swap(a.durability, b.durability);
  swap(a.__isset, b.__isset);
}

TTableDescriptor::TTableDescriptor(const TTableDescriptor& other193) {
  tableName = other193.tableName;
  columns = other193.columns;
  attributes = other193.attributes;
  durability = other193.durability;
  __isset = other193.__isset;
}
TTableDescriptor& TTableDescriptor::operator=(const TTableDescriptor& other194) {
  tableName = other194.tableName;
  columns = other194.columns;
  attributes = other194.attributes;
  durability = other194.durability;
  __isset = other194.__isset;
  return *this;
}
void TTableDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableDescriptor(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "durability="; (__isset.durability ? (out << to_string(durability)) : (out << "<null>"));
  out << ")";
}


TNamespaceDescriptor::~TNamespaceDescriptor() noexcept {
}


void TNamespaceDescriptor::__set_name(const std::string& val) {
  this->name = val;
}

void TNamespaceDescriptor::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TNamespaceDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TNamespaceDescriptor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _ktype196;
            ::apache::thrift::protocol::TType _vtype197;
            xfer += iprot->readMapBegin(_ktype196, _vtype197, _size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              std::string _key200;
              xfer += iprot->readString(_key200);
              std::string& _val201 = this->configuration[_key200];
              xfer += iprot->readString(_val201);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TNamespaceDescriptor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNamespaceDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter202;
      for (_iter202 = this->configuration.begin(); _iter202 != this->configuration.end(); ++_iter202)
      {
        xfer += oprot->writeString(_iter202->first);
        xfer += oprot->writeString(_iter202->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TNamespaceDescriptor &a, TNamespaceDescriptor &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TNamespaceDescriptor::TNamespaceDescriptor(const TNamespaceDescriptor& other203) {
  name = other203.name;
  configuration = other203.configuration;
  __isset = other203.__isset;
}
TNamespaceDescriptor& TNamespaceDescriptor::operator=(const TNamespaceDescriptor& other204) {
  name = other204.name;
  configuration = other204.configuration;
  __isset = other204.__isset;
  return *this;
}
void TNamespaceDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNamespaceDescriptor(";
  out << "name=" << to_string(name);
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TIOError::~TIOError() noexcept {
}


void TIOError::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TIOError& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIOError");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIOError &a, TIOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIOError::TIOError(const TIOError& other205) : TException() {
  message = other205.message;
  __isset = other205.__isset;
}
TIOError& TIOError::operator=(const TIOError& other206) {
  message = other206.message;
  __isset = other206.__isset;
  return *this;
}
void TIOError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIOError(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}

const char* TIOError::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TIOError";
  }
}


TIllegalArgument::~TIllegalArgument() noexcept {
}


void TIllegalArgument::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TIllegalArgument& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TIllegalArgument::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TIllegalArgument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIllegalArgument");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TIllegalArgument &a, TIllegalArgument &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TIllegalArgument::TIllegalArgument(const TIllegalArgument& other207) : TException() {
  message = other207.message;
  __isset = other207.__isset;
}
TIllegalArgument& TIllegalArgument::operator=(const TIllegalArgument& other208) {
  message = other208.message;
  __isset = other208.__isset;
  return *this;
}
void TIllegalArgument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIllegalArgument(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}

const char* TIllegalArgument::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: TIllegalArgument";
  }
}

}}}} // namespace
