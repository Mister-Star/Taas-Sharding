// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "proto/transaction.pb.h"
#include "proto/node.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fserver_2eproto;
namespace proto {
class ChangeServerStateRequest;
struct ChangeServerStateRequestDefaultTypeInternal;
extern ChangeServerStateRequestDefaultTypeInternal _ChangeServerStateRequest_default_instance_;
class ChangeServerStateResponse;
struct ChangeServerStateResponseDefaultTypeInternal;
extern ChangeServerStateResponseDefaultTypeInternal _ChangeServerStateResponse_default_instance_;
class EpochReplicationAck;
struct EpochReplicationAckDefaultTypeInternal;
extern EpochReplicationAckDefaultTypeInternal _EpochReplicationAck_default_instance_;
class ForwardEpochRequest;
struct ForwardEpochRequestDefaultTypeInternal;
extern ForwardEpochRequestDefaultTypeInternal _ForwardEpochRequest_default_instance_;
class KeyMasterMetadata;
struct KeyMasterMetadataDefaultTypeInternal;
extern KeyMasterMetadataDefaultTypeInternal _KeyMasterMetadata_default_instance_;
class LookupMasterRequest;
struct LookupMasterRequestDefaultTypeInternal;
extern LookupMasterRequestDefaultTypeInternal _LookupMasterRequest_default_instance_;
class LookupMasterResponse;
struct LookupMasterResponseDefaultTypeInternal;
extern LookupMasterResponseDefaultTypeInternal _LookupMasterResponse_default_instance_;
class MasterMetadata;
struct MasterMetadataDefaultTypeInternal;
extern MasterMetadataDefaultTypeInternal _MasterMetadata_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class RaftAcceptRequest;
struct RaftAcceptRequestDefaultTypeInternal;
extern RaftAcceptRequestDefaultTypeInternal _RaftAcceptRequest_default_instance_;
class RaftAcceptResponse;
struct RaftAcceptResponseDefaultTypeInternal;
extern RaftAcceptResponseDefaultTypeInternal _RaftAcceptResponse_default_instance_;
class RaftCommitRequest;
struct RaftCommitRequestDefaultTypeInternal;
extern RaftCommitRequestDefaultTypeInternal _RaftCommitRequest_default_instance_;
class RaftCommitResponse;
struct RaftCommitResponseDefaultTypeInternal;
extern RaftCommitResponseDefaultTypeInternal _RaftCommitResponse_default_instance_;
class RaftPropose;
struct RaftProposeDefaultTypeInternal;
extern RaftProposeDefaultTypeInternal _RaftPropose_default_instance_;
class RaftRequest;
struct RaftRequestDefaultTypeInternal;
extern RaftRequestDefaultTypeInternal _RaftRequest_default_instance_;
class RaftResponse;
struct RaftResponseDefaultTypeInternal;
extern RaftResponseDefaultTypeInternal _RaftResponse_default_instance_;
class ReplyTransactionToClient;
struct ReplyTransactionToClientDefaultTypeInternal;
extern ReplyTransactionToClientDefaultTypeInternal _ReplyTransactionToClient_default_instance_;
class Signal;
struct SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class StatsRequest;
struct StatsRequestDefaultTypeInternal;
extern StatsRequestDefaultTypeInternal _StatsRequest_default_instance_;
class StatsResponse;
struct StatsResponseDefaultTypeInternal;
extern StatsResponseDefaultTypeInternal _StatsResponse_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::ChangeServerStateRequest* Arena::CreateMaybeMessage<::proto::ChangeServerStateRequest>(Arena*);
template<> ::proto::ChangeServerStateResponse* Arena::CreateMaybeMessage<::proto::ChangeServerStateResponse>(Arena*);
template<> ::proto::EpochReplicationAck* Arena::CreateMaybeMessage<::proto::EpochReplicationAck>(Arena*);
template<> ::proto::ForwardEpochRequest* Arena::CreateMaybeMessage<::proto::ForwardEpochRequest>(Arena*);
template<> ::proto::KeyMasterMetadata* Arena::CreateMaybeMessage<::proto::KeyMasterMetadata>(Arena*);
template<> ::proto::LookupMasterRequest* Arena::CreateMaybeMessage<::proto::LookupMasterRequest>(Arena*);
template<> ::proto::LookupMasterResponse* Arena::CreateMaybeMessage<::proto::LookupMasterResponse>(Arena*);
template<> ::proto::MasterMetadata* Arena::CreateMaybeMessage<::proto::MasterMetadata>(Arena*);
template<> ::proto::Ping* Arena::CreateMaybeMessage<::proto::Ping>(Arena*);
template<> ::proto::Pong* Arena::CreateMaybeMessage<::proto::Pong>(Arena*);
template<> ::proto::RaftAcceptRequest* Arena::CreateMaybeMessage<::proto::RaftAcceptRequest>(Arena*);
template<> ::proto::RaftAcceptResponse* Arena::CreateMaybeMessage<::proto::RaftAcceptResponse>(Arena*);
template<> ::proto::RaftCommitRequest* Arena::CreateMaybeMessage<::proto::RaftCommitRequest>(Arena*);
template<> ::proto::RaftCommitResponse* Arena::CreateMaybeMessage<::proto::RaftCommitResponse>(Arena*);
template<> ::proto::RaftPropose* Arena::CreateMaybeMessage<::proto::RaftPropose>(Arena*);
template<> ::proto::RaftRequest* Arena::CreateMaybeMessage<::proto::RaftRequest>(Arena*);
template<> ::proto::RaftResponse* Arena::CreateMaybeMessage<::proto::RaftResponse>(Arena*);
template<> ::proto::ReplyTransactionToClient* Arena::CreateMaybeMessage<::proto::ReplyTransactionToClient>(Arena*);
template<> ::proto::Signal* Arena::CreateMaybeMessage<::proto::Signal>(Arena*);
template<> ::proto::StatsRequest* Arena::CreateMaybeMessage<::proto::StatsRequest>(Arena*);
template<> ::proto::StatsResponse* Arena::CreateMaybeMessage<::proto::StatsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class ReplyTransactionToClient final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ReplyTransactionToClient) */ {
 public:
  inline ReplyTransactionToClient() : ReplyTransactionToClient(nullptr) {}
  ~ReplyTransactionToClient() override;
  explicit PROTOBUF_CONSTEXPR ReplyTransactionToClient(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplyTransactionToClient(const ReplyTransactionToClient& from);
  ReplyTransactionToClient(ReplyTransactionToClient&& from) noexcept
    : ReplyTransactionToClient() {
    *this = ::std::move(from);
  }

  inline ReplyTransactionToClient& operator=(const ReplyTransactionToClient& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyTransactionToClient& operator=(ReplyTransactionToClient&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplyTransactionToClient& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplyTransactionToClient* internal_default_instance() {
    return reinterpret_cast<const ReplyTransactionToClient*>(
               &_ReplyTransactionToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReplyTransactionToClient& a, ReplyTransactionToClient& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyTransactionToClient* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplyTransactionToClient* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplyTransactionToClient* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplyTransactionToClient>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplyTransactionToClient& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReplyTransactionToClient& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyTransactionToClient* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ReplyTransactionToClient";
  }
  protected:
  explicit ReplyTransactionToClient(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendNodeFieldNumber = 3,
    kRecvNodeFieldNumber = 4,
    kClientTxnIdFieldNumber = 1,
    kTxnStateFieldNumber = 2,
  };
  // .proto.Node send_node = 3;
  bool has_send_node() const;
  private:
  bool _internal_has_send_node() const;
  public:
  void clear_send_node();
  const ::proto::Node& send_node() const;
  PROTOBUF_NODISCARD ::proto::Node* release_send_node();
  ::proto::Node* mutable_send_node();
  void set_allocated_send_node(::proto::Node* send_node);
  private:
  const ::proto::Node& _internal_send_node() const;
  ::proto::Node* _internal_mutable_send_node();
  public:
  void unsafe_arena_set_allocated_send_node(
      ::proto::Node* send_node);
  ::proto::Node* unsafe_arena_release_send_node();

  // .proto.Node recv_node = 4;
  bool has_recv_node() const;
  private:
  bool _internal_has_recv_node() const;
  public:
  void clear_recv_node();
  const ::proto::Node& recv_node() const;
  PROTOBUF_NODISCARD ::proto::Node* release_recv_node();
  ::proto::Node* mutable_recv_node();
  void set_allocated_recv_node(::proto::Node* recv_node);
  private:
  const ::proto::Node& _internal_recv_node() const;
  ::proto::Node* _internal_mutable_recv_node();
  public:
  void unsafe_arena_set_allocated_recv_node(
      ::proto::Node* recv_node);
  ::proto::Node* unsafe_arena_release_recv_node();

  // uint64 client_txn_id = 1;
  void clear_client_txn_id();
  uint64_t client_txn_id() const;
  void set_client_txn_id(uint64_t value);
  private:
  uint64_t _internal_client_txn_id() const;
  void _internal_set_client_txn_id(uint64_t value);
  public:

  // .proto.TxnState txn_state = 2;
  void clear_txn_state();
  ::proto::TxnState txn_state() const;
  void set_txn_state(::proto::TxnState value);
  private:
  ::proto::TxnState _internal_txn_state() const;
  void _internal_set_txn_state(::proto::TxnState value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ReplyTransactionToClient)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::proto::Node* send_node_;
  ::proto::Node* recv_node_;
  uint64_t client_txn_id_;
  int txn_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftRequest) */ {
 public:
  inline RaftRequest() : RaftRequest(nullptr) {}
  ~RaftRequest() override;
  explicit PROTOBUF_CONSTEXPR RaftRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftRequest(const RaftRequest& from);
  RaftRequest(RaftRequest&& from) noexcept
    : RaftRequest() {
    *this = ::std::move(from);
  }

  inline RaftRequest& operator=(const RaftRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftRequest& operator=(RaftRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kPing = 1,
    kSignal = 2,
    kLookupMaster = 3,
    kForwardEpoch = 4,
    kEpochReplicationAck = 5,
    kRaftPropose = 6,
    kRaftAccept = 7,
    kRaftCommit = 8,
    kStats = 9,
    kChangeServerState = 10,
    TYPE_NOT_SET = 0,
  };

  static inline const RaftRequest* internal_default_instance() {
    return reinterpret_cast<const RaftRequest*>(
               &_RaftRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RaftRequest& a, RaftRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftRequest";
  }
  protected:
  explicit RaftRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingFieldNumber = 1,
    kSignalFieldNumber = 2,
    kLookupMasterFieldNumber = 3,
    kForwardEpochFieldNumber = 4,
    kEpochReplicationAckFieldNumber = 5,
    kRaftProposeFieldNumber = 6,
    kRaftAcceptFieldNumber = 7,
    kRaftCommitFieldNumber = 8,
    kStatsFieldNumber = 9,
    kChangeServerStateFieldNumber = 10,
  };
  // .proto.Ping ping = 1;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::proto::Ping& ping() const;
  PROTOBUF_NODISCARD ::proto::Ping* release_ping();
  ::proto::Ping* mutable_ping();
  void set_allocated_ping(::proto::Ping* ping);
  private:
  const ::proto::Ping& _internal_ping() const;
  ::proto::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::proto::Ping* ping);
  ::proto::Ping* unsafe_arena_release_ping();

  // .proto.Signal signal = 2;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  const ::proto::Signal& signal() const;
  PROTOBUF_NODISCARD ::proto::Signal* release_signal();
  ::proto::Signal* mutable_signal();
  void set_allocated_signal(::proto::Signal* signal);
  private:
  const ::proto::Signal& _internal_signal() const;
  ::proto::Signal* _internal_mutable_signal();
  public:
  void unsafe_arena_set_allocated_signal(
      ::proto::Signal* signal);
  ::proto::Signal* unsafe_arena_release_signal();

  // .proto.LookupMasterRequest lookup_master = 3;
  bool has_lookup_master() const;
  private:
  bool _internal_has_lookup_master() const;
  public:
  void clear_lookup_master();
  const ::proto::LookupMasterRequest& lookup_master() const;
  PROTOBUF_NODISCARD ::proto::LookupMasterRequest* release_lookup_master();
  ::proto::LookupMasterRequest* mutable_lookup_master();
  void set_allocated_lookup_master(::proto::LookupMasterRequest* lookup_master);
  private:
  const ::proto::LookupMasterRequest& _internal_lookup_master() const;
  ::proto::LookupMasterRequest* _internal_mutable_lookup_master();
  public:
  void unsafe_arena_set_allocated_lookup_master(
      ::proto::LookupMasterRequest* lookup_master);
  ::proto::LookupMasterRequest* unsafe_arena_release_lookup_master();

  // .proto.ForwardEpochRequest forward_epoch = 4;
  bool has_forward_epoch() const;
  private:
  bool _internal_has_forward_epoch() const;
  public:
  void clear_forward_epoch();
  const ::proto::ForwardEpochRequest& forward_epoch() const;
  PROTOBUF_NODISCARD ::proto::ForwardEpochRequest* release_forward_epoch();
  ::proto::ForwardEpochRequest* mutable_forward_epoch();
  void set_allocated_forward_epoch(::proto::ForwardEpochRequest* forward_epoch);
  private:
  const ::proto::ForwardEpochRequest& _internal_forward_epoch() const;
  ::proto::ForwardEpochRequest* _internal_mutable_forward_epoch();
  public:
  void unsafe_arena_set_allocated_forward_epoch(
      ::proto::ForwardEpochRequest* forward_epoch);
  ::proto::ForwardEpochRequest* unsafe_arena_release_forward_epoch();

  // .proto.EpochReplicationAck epoch_replication_ack = 5;
  bool has_epoch_replication_ack() const;
  private:
  bool _internal_has_epoch_replication_ack() const;
  public:
  void clear_epoch_replication_ack();
  const ::proto::EpochReplicationAck& epoch_replication_ack() const;
  PROTOBUF_NODISCARD ::proto::EpochReplicationAck* release_epoch_replication_ack();
  ::proto::EpochReplicationAck* mutable_epoch_replication_ack();
  void set_allocated_epoch_replication_ack(::proto::EpochReplicationAck* epoch_replication_ack);
  private:
  const ::proto::EpochReplicationAck& _internal_epoch_replication_ack() const;
  ::proto::EpochReplicationAck* _internal_mutable_epoch_replication_ack();
  public:
  void unsafe_arena_set_allocated_epoch_replication_ack(
      ::proto::EpochReplicationAck* epoch_replication_ack);
  ::proto::EpochReplicationAck* unsafe_arena_release_epoch_replication_ack();

  // .proto.RaftPropose raft_propose = 6;
  bool has_raft_propose() const;
  private:
  bool _internal_has_raft_propose() const;
  public:
  void clear_raft_propose();
  const ::proto::RaftPropose& raft_propose() const;
  PROTOBUF_NODISCARD ::proto::RaftPropose* release_raft_propose();
  ::proto::RaftPropose* mutable_raft_propose();
  void set_allocated_raft_propose(::proto::RaftPropose* raft_propose);
  private:
  const ::proto::RaftPropose& _internal_raft_propose() const;
  ::proto::RaftPropose* _internal_mutable_raft_propose();
  public:
  void unsafe_arena_set_allocated_raft_propose(
      ::proto::RaftPropose* raft_propose);
  ::proto::RaftPropose* unsafe_arena_release_raft_propose();

  // .proto.RaftAcceptRequest raft_accept = 7;
  bool has_raft_accept() const;
  private:
  bool _internal_has_raft_accept() const;
  public:
  void clear_raft_accept();
  const ::proto::RaftAcceptRequest& raft_accept() const;
  PROTOBUF_NODISCARD ::proto::RaftAcceptRequest* release_raft_accept();
  ::proto::RaftAcceptRequest* mutable_raft_accept();
  void set_allocated_raft_accept(::proto::RaftAcceptRequest* raft_accept);
  private:
  const ::proto::RaftAcceptRequest& _internal_raft_accept() const;
  ::proto::RaftAcceptRequest* _internal_mutable_raft_accept();
  public:
  void unsafe_arena_set_allocated_raft_accept(
      ::proto::RaftAcceptRequest* raft_accept);
  ::proto::RaftAcceptRequest* unsafe_arena_release_raft_accept();

  // .proto.RaftCommitRequest raft_commit = 8;
  bool has_raft_commit() const;
  private:
  bool _internal_has_raft_commit() const;
  public:
  void clear_raft_commit();
  const ::proto::RaftCommitRequest& raft_commit() const;
  PROTOBUF_NODISCARD ::proto::RaftCommitRequest* release_raft_commit();
  ::proto::RaftCommitRequest* mutable_raft_commit();
  void set_allocated_raft_commit(::proto::RaftCommitRequest* raft_commit);
  private:
  const ::proto::RaftCommitRequest& _internal_raft_commit() const;
  ::proto::RaftCommitRequest* _internal_mutable_raft_commit();
  public:
  void unsafe_arena_set_allocated_raft_commit(
      ::proto::RaftCommitRequest* raft_commit);
  ::proto::RaftCommitRequest* unsafe_arena_release_raft_commit();

  // .proto.StatsRequest stats = 9;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::proto::StatsRequest& stats() const;
  PROTOBUF_NODISCARD ::proto::StatsRequest* release_stats();
  ::proto::StatsRequest* mutable_stats();
  void set_allocated_stats(::proto::StatsRequest* stats);
  private:
  const ::proto::StatsRequest& _internal_stats() const;
  ::proto::StatsRequest* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::proto::StatsRequest* stats);
  ::proto::StatsRequest* unsafe_arena_release_stats();

  // .proto.ChangeServerStateRequest change_server_state = 10;
  bool has_change_server_state() const;
  private:
  bool _internal_has_change_server_state() const;
  public:
  void clear_change_server_state();
  const ::proto::ChangeServerStateRequest& change_server_state() const;
  PROTOBUF_NODISCARD ::proto::ChangeServerStateRequest* release_change_server_state();
  ::proto::ChangeServerStateRequest* mutable_change_server_state();
  void set_allocated_change_server_state(::proto::ChangeServerStateRequest* change_server_state);
  private:
  const ::proto::ChangeServerStateRequest& _internal_change_server_state() const;
  ::proto::ChangeServerStateRequest* _internal_mutable_change_server_state();
  public:
  void unsafe_arena_set_allocated_change_server_state(
      ::proto::ChangeServerStateRequest* change_server_state);
  ::proto::ChangeServerStateRequest* unsafe_arena_release_change_server_state();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:proto.RaftRequest)
 private:
  class _Internal;
  void set_has_ping();
  void set_has_signal();
  void set_has_lookup_master();
  void set_has_forward_epoch();
  void set_has_epoch_replication_ack();
  void set_has_raft_propose();
  void set_has_raft_accept();
  void set_has_raft_commit();
  void set_has_stats();
  void set_has_change_server_state();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::proto::Ping* ping_;
    ::proto::Signal* signal_;
    ::proto::LookupMasterRequest* lookup_master_;
    ::proto::ForwardEpochRequest* forward_epoch_;
    ::proto::EpochReplicationAck* epoch_replication_ack_;
    ::proto::RaftPropose* raft_propose_;
    ::proto::RaftAcceptRequest* raft_accept_;
    ::proto::RaftCommitRequest* raft_commit_;
    ::proto::StatsRequest* stats_;
    ::proto::ChangeServerStateRequest* change_server_state_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // int32 from = 1;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // int32 to = 2;
  void clear_to();
  int32_t to() const;
  void set_to(int32_t value);
  private:
  int32_t _internal_to() const;
  void _internal_set_to(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t from_;
  int32_t to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Signal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Signal) */ {
 public:
  inline Signal() : Signal(nullptr) {}
  ~Signal() override;
  explicit PROTOBUF_CONSTEXPR Signal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Signal(const Signal& from);
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signal& operator=(Signal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }
  inline void Swap(Signal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Signal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Signal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Signal";
  }
  protected:
  explicit Signal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
  };
  // int32 from = 1;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Signal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class LookupMasterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LookupMasterRequest) */ {
 public:
  inline LookupMasterRequest() : LookupMasterRequest(nullptr) {}
  ~LookupMasterRequest() override;
  explicit PROTOBUF_CONSTEXPR LookupMasterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupMasterRequest(const LookupMasterRequest& from);
  LookupMasterRequest(LookupMasterRequest&& from) noexcept
    : LookupMasterRequest() {
    *this = ::std::move(from);
  }

  inline LookupMasterRequest& operator=(const LookupMasterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupMasterRequest& operator=(LookupMasterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupMasterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupMasterRequest* internal_default_instance() {
    return reinterpret_cast<const LookupMasterRequest*>(
               &_LookupMasterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LookupMasterRequest& a, LookupMasterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupMasterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupMasterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupMasterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupMasterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupMasterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupMasterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupMasterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LookupMasterRequest";
  }
  protected:
  explicit LookupMasterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnIdsFieldNumber = 1,
    kKeysFieldNumber = 2,
  };
  // repeated uint64 txn_ids = 1;
  int txn_ids_size() const;
  private:
  int _internal_txn_ids_size() const;
  public:
  void clear_txn_ids();
  private:
  uint64_t _internal_txn_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_txn_ids() const;
  void _internal_add_txn_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_txn_ids();
  public:
  uint64_t txn_ids(int index) const;
  void set_txn_ids(int index, uint64_t value);
  void add_txn_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_txn_ids();

  // repeated bytes keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:proto.LookupMasterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > txn_ids_;
  mutable std::atomic<int> _txn_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class ForwardEpochRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ForwardEpochRequest) */ {
 public:
  inline ForwardEpochRequest() : ForwardEpochRequest(nullptr) {}
  ~ForwardEpochRequest() override;
  explicit PROTOBUF_CONSTEXPR ForwardEpochRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForwardEpochRequest(const ForwardEpochRequest& from);
  ForwardEpochRequest(ForwardEpochRequest&& from) noexcept
    : ForwardEpochRequest() {
    *this = ::std::move(from);
  }

  inline ForwardEpochRequest& operator=(const ForwardEpochRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForwardEpochRequest& operator=(ForwardEpochRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForwardEpochRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForwardEpochRequest* internal_default_instance() {
    return reinterpret_cast<const ForwardEpochRequest*>(
               &_ForwardEpochRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ForwardEpochRequest& a, ForwardEpochRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ForwardEpochRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForwardEpochRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForwardEpochRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForwardEpochRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForwardEpochRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ForwardEpochRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForwardEpochRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ForwardEpochRequest";
  }
  protected:
  explicit ForwardEpochRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
  };
  // int32 from = 1;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // int32 to = 2;
  void clear_to();
  int32_t to() const;
  void set_to(int32_t value);
  private:
  int32_t _internal_to() const;
  void _internal_set_to(int32_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ForwardEpochRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t from_;
  int32_t to_;
  uint64_t epoch_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class EpochReplicationAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.EpochReplicationAck) */ {
 public:
  inline EpochReplicationAck() : EpochReplicationAck(nullptr) {}
  ~EpochReplicationAck() override;
  explicit PROTOBUF_CONSTEXPR EpochReplicationAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EpochReplicationAck(const EpochReplicationAck& from);
  EpochReplicationAck(EpochReplicationAck&& from) noexcept
    : EpochReplicationAck() {
    *this = ::std::move(from);
  }

  inline EpochReplicationAck& operator=(const EpochReplicationAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochReplicationAck& operator=(EpochReplicationAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpochReplicationAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpochReplicationAck* internal_default_instance() {
    return reinterpret_cast<const EpochReplicationAck*>(
               &_EpochReplicationAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EpochReplicationAck& a, EpochReplicationAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochReplicationAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochReplicationAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpochReplicationAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpochReplicationAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EpochReplicationAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EpochReplicationAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochReplicationAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.EpochReplicationAck";
  }
  protected:
  explicit EpochReplicationAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochIdFieldNumber = 1,
  };
  // uint64 epoch_id = 1;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.EpochReplicationAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t epoch_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftPropose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftPropose) */ {
 public:
  inline RaftPropose() : RaftPropose(nullptr) {}
  ~RaftPropose() override;
  explicit PROTOBUF_CONSTEXPR RaftPropose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftPropose(const RaftPropose& from);
  RaftPropose(RaftPropose&& from) noexcept
    : RaftPropose() {
    *this = ::std::move(from);
  }

  inline RaftPropose& operator=(const RaftPropose& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftPropose& operator=(RaftPropose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftPropose& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftPropose* internal_default_instance() {
    return reinterpret_cast<const RaftPropose*>(
               &_RaftPropose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RaftPropose& a, RaftPropose& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftPropose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftPropose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftPropose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftPropose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftPropose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftPropose& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftPropose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftPropose";
  }
  protected:
  explicit RaftPropose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RaftPropose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftAcceptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftAcceptRequest) */ {
 public:
  inline RaftAcceptRequest() : RaftAcceptRequest(nullptr) {}
  ~RaftAcceptRequest() override;
  explicit PROTOBUF_CONSTEXPR RaftAcceptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftAcceptRequest(const RaftAcceptRequest& from);
  RaftAcceptRequest(RaftAcceptRequest&& from) noexcept
    : RaftAcceptRequest() {
    *this = ::std::move(from);
  }

  inline RaftAcceptRequest& operator=(const RaftAcceptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftAcceptRequest& operator=(RaftAcceptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftAcceptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftAcceptRequest* internal_default_instance() {
    return reinterpret_cast<const RaftAcceptRequest*>(
               &_RaftAcceptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RaftAcceptRequest& a, RaftAcceptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftAcceptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftAcceptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftAcceptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftAcceptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftAcceptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftAcceptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftAcceptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftAcceptRequest";
  }
  protected:
  explicit RaftAcceptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RaftAcceptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint64_t epoch_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftCommitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftCommitRequest) */ {
 public:
  inline RaftCommitRequest() : RaftCommitRequest(nullptr) {}
  ~RaftCommitRequest() override;
  explicit PROTOBUF_CONSTEXPR RaftCommitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftCommitRequest(const RaftCommitRequest& from);
  RaftCommitRequest(RaftCommitRequest&& from) noexcept
    : RaftCommitRequest() {
    *this = ::std::move(from);
  }

  inline RaftCommitRequest& operator=(const RaftCommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftCommitRequest& operator=(RaftCommitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftCommitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftCommitRequest* internal_default_instance() {
    return reinterpret_cast<const RaftCommitRequest*>(
               &_RaftCommitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RaftCommitRequest& a, RaftCommitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftCommitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftCommitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftCommitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftCommitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftCommitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftCommitRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftCommitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftCommitRequest";
  }
  protected:
  explicit RaftCommitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RaftCommitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint64_t epoch_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class StatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.StatsRequest) */ {
 public:
  inline StatsRequest() : StatsRequest(nullptr) {}
  ~StatsRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsRequest(const StatsRequest& from);
  StatsRequest(StatsRequest&& from) noexcept
    : StatsRequest() {
    *this = ::std::move(from);
  }

  inline StatsRequest& operator=(const StatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsRequest& operator=(StatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsRequest* internal_default_instance() {
    return reinterpret_cast<const StatsRequest*>(
               &_StatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StatsRequest& a, StatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.StatsRequest";
  }
  protected:
  explicit StatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kLevelFieldNumber = 3,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint32 level = 3;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.StatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint32_t level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class ChangeServerStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ChangeServerStateRequest) */ {
 public:
  inline ChangeServerStateRequest() : ChangeServerStateRequest(nullptr) {}
  ~ChangeServerStateRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeServerStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeServerStateRequest(const ChangeServerStateRequest& from);
  ChangeServerStateRequest(ChangeServerStateRequest&& from) noexcept
    : ChangeServerStateRequest() {
    *this = ::std::move(from);
  }

  inline ChangeServerStateRequest& operator=(const ChangeServerStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeServerStateRequest& operator=(ChangeServerStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeServerStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeServerStateRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeServerStateRequest*>(
               &_ChangeServerStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChangeServerStateRequest& a, ChangeServerStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeServerStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeServerStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeServerStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeServerStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeServerStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeServerStateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeServerStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ChangeServerStateRequest";
  }
  protected:
  explicit ChangeServerStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kTargetFieldNumber = 3,
    kStateFieldNumber = 4,
    kEpochIdFieldNumber = 6,
    kPullServerIdFieldNumber = 5,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint32 target = 3;
  void clear_target();
  uint32_t target() const;
  void set_target(uint32_t value);
  private:
  uint32_t _internal_target() const;
  void _internal_set_target(uint32_t value);
  public:

  // uint32 state = 4;
  void clear_state();
  uint32_t state() const;
  void set_state(uint32_t value);
  private:
  uint32_t _internal_state() const;
  void _internal_set_state(uint32_t value);
  public:

  // uint64 epoch_id = 6;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // uint32 pull_server_id = 5;
  void clear_pull_server_id();
  uint32_t pull_server_id() const;
  void set_pull_server_id(uint32_t value);
  private:
  uint32_t _internal_pull_server_id() const;
  void _internal_set_pull_server_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ChangeServerStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint32_t target_;
  uint32_t state_;
  uint64_t epoch_id_;
  uint32_t pull_server_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftResponse) */ {
 public:
  inline RaftResponse() : RaftResponse(nullptr) {}
  ~RaftResponse() override;
  explicit PROTOBUF_CONSTEXPR RaftResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftResponse(const RaftResponse& from);
  RaftResponse(RaftResponse&& from) noexcept
    : RaftResponse() {
    *this = ::std::move(from);
  }

  inline RaftResponse& operator=(const RaftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftResponse& operator=(RaftResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftResponse& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kPong = 1,
    kLookupMaster = 2,
    kRaftAccept = 3,
    kRaftCommit = 4,
    kStats = 5,
    kChangeServerState = 6,
    TYPE_NOT_SET = 0,
  };

  static inline const RaftResponse* internal_default_instance() {
    return reinterpret_cast<const RaftResponse*>(
               &_RaftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RaftResponse& a, RaftResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftResponse";
  }
  protected:
  explicit RaftResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPongFieldNumber = 1,
    kLookupMasterFieldNumber = 2,
    kRaftAcceptFieldNumber = 3,
    kRaftCommitFieldNumber = 4,
    kStatsFieldNumber = 5,
    kChangeServerStateFieldNumber = 6,
  };
  // .proto.Pong pong = 1;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::proto::Pong& pong() const;
  PROTOBUF_NODISCARD ::proto::Pong* release_pong();
  ::proto::Pong* mutable_pong();
  void set_allocated_pong(::proto::Pong* pong);
  private:
  const ::proto::Pong& _internal_pong() const;
  ::proto::Pong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::proto::Pong* pong);
  ::proto::Pong* unsafe_arena_release_pong();

  // .proto.LookupMasterResponse lookup_master = 2;
  bool has_lookup_master() const;
  private:
  bool _internal_has_lookup_master() const;
  public:
  void clear_lookup_master();
  const ::proto::LookupMasterResponse& lookup_master() const;
  PROTOBUF_NODISCARD ::proto::LookupMasterResponse* release_lookup_master();
  ::proto::LookupMasterResponse* mutable_lookup_master();
  void set_allocated_lookup_master(::proto::LookupMasterResponse* lookup_master);
  private:
  const ::proto::LookupMasterResponse& _internal_lookup_master() const;
  ::proto::LookupMasterResponse* _internal_mutable_lookup_master();
  public:
  void unsafe_arena_set_allocated_lookup_master(
      ::proto::LookupMasterResponse* lookup_master);
  ::proto::LookupMasterResponse* unsafe_arena_release_lookup_master();

  // .proto.RaftAcceptResponse raft_accept = 3;
  bool has_raft_accept() const;
  private:
  bool _internal_has_raft_accept() const;
  public:
  void clear_raft_accept();
  const ::proto::RaftAcceptResponse& raft_accept() const;
  PROTOBUF_NODISCARD ::proto::RaftAcceptResponse* release_raft_accept();
  ::proto::RaftAcceptResponse* mutable_raft_accept();
  void set_allocated_raft_accept(::proto::RaftAcceptResponse* raft_accept);
  private:
  const ::proto::RaftAcceptResponse& _internal_raft_accept() const;
  ::proto::RaftAcceptResponse* _internal_mutable_raft_accept();
  public:
  void unsafe_arena_set_allocated_raft_accept(
      ::proto::RaftAcceptResponse* raft_accept);
  ::proto::RaftAcceptResponse* unsafe_arena_release_raft_accept();

  // .proto.RaftCommitResponse raft_commit = 4;
  bool has_raft_commit() const;
  private:
  bool _internal_has_raft_commit() const;
  public:
  void clear_raft_commit();
  const ::proto::RaftCommitResponse& raft_commit() const;
  PROTOBUF_NODISCARD ::proto::RaftCommitResponse* release_raft_commit();
  ::proto::RaftCommitResponse* mutable_raft_commit();
  void set_allocated_raft_commit(::proto::RaftCommitResponse* raft_commit);
  private:
  const ::proto::RaftCommitResponse& _internal_raft_commit() const;
  ::proto::RaftCommitResponse* _internal_mutable_raft_commit();
  public:
  void unsafe_arena_set_allocated_raft_commit(
      ::proto::RaftCommitResponse* raft_commit);
  ::proto::RaftCommitResponse* unsafe_arena_release_raft_commit();

  // .proto.StatsResponse stats = 5;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::proto::StatsResponse& stats() const;
  PROTOBUF_NODISCARD ::proto::StatsResponse* release_stats();
  ::proto::StatsResponse* mutable_stats();
  void set_allocated_stats(::proto::StatsResponse* stats);
  private:
  const ::proto::StatsResponse& _internal_stats() const;
  ::proto::StatsResponse* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::proto::StatsResponse* stats);
  ::proto::StatsResponse* unsafe_arena_release_stats();

  // .proto.ChangeServerStateResponse change_server_state = 6;
  bool has_change_server_state() const;
  private:
  bool _internal_has_change_server_state() const;
  public:
  void clear_change_server_state();
  const ::proto::ChangeServerStateResponse& change_server_state() const;
  PROTOBUF_NODISCARD ::proto::ChangeServerStateResponse* release_change_server_state();
  ::proto::ChangeServerStateResponse* mutable_change_server_state();
  void set_allocated_change_server_state(::proto::ChangeServerStateResponse* change_server_state);
  private:
  const ::proto::ChangeServerStateResponse& _internal_change_server_state() const;
  ::proto::ChangeServerStateResponse* _internal_mutable_change_server_state();
  public:
  void unsafe_arena_set_allocated_change_server_state(
      ::proto::ChangeServerStateResponse* change_server_state);
  ::proto::ChangeServerStateResponse* unsafe_arena_release_change_server_state();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:proto.RaftResponse)
 private:
  class _Internal;
  void set_has_pong();
  void set_has_lookup_master();
  void set_has_raft_accept();
  void set_has_raft_commit();
  void set_has_stats();
  void set_has_change_server_state();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::proto::Pong* pong_;
    ::proto::LookupMasterResponse* lookup_master_;
    ::proto::RaftAcceptResponse* raft_accept_;
    ::proto::RaftCommitResponse* raft_commit_;
    ::proto::StatsResponse* stats_;
    ::proto::ChangeServerStateResponse* change_server_state_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Pong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  explicit PROTOBUF_CONSTEXPR Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Pong& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kTimeFieldNumber = 3,
    kEpochIdFieldNumber = 4,
  };
  // int32 from = 1;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // int32 to = 2;
  void clear_to();
  int32_t to() const;
  void set_to(int32_t value);
  private:
  int32_t _internal_to() const;
  void _internal_set_to(int32_t value);
  public:

  // int64 time = 3;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // int64 epoch_id = 4;
  void clear_epoch_id();
  int64_t epoch_id() const;
  void set_epoch_id(int64_t value);
  private:
  int64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t from_;
  int32_t to_;
  int64_t time_;
  int64_t epoch_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class MasterMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MasterMetadata) */ {
 public:
  inline MasterMetadata() : MasterMetadata(nullptr) {}
  ~MasterMetadata() override;
  explicit PROTOBUF_CONSTEXPR MasterMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterMetadata(const MasterMetadata& from);
  MasterMetadata(MasterMetadata&& from) noexcept
    : MasterMetadata() {
    *this = ::std::move(from);
  }

  inline MasterMetadata& operator=(const MasterMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterMetadata& operator=(MasterMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterMetadata* internal_default_instance() {
    return reinterpret_cast<const MasterMetadata*>(
               &_MasterMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MasterMetadata& a, MasterMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MasterMetadata";
  }
  protected:
  explicit MasterMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterFieldNumber = 1,
    kEpochCountFieldNumber = 2,
  };
  // uint32 master = 1;
  void clear_master();
  uint32_t master() const;
  void set_master(uint32_t value);
  private:
  uint32_t _internal_master() const;
  void _internal_set_master(uint32_t value);
  public:

  // uint32 epoch_count = 2;
  void clear_epoch_count();
  uint32_t epoch_count() const;
  void set_epoch_count(uint32_t value);
  private:
  uint32_t _internal_epoch_count() const;
  void _internal_set_epoch_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MasterMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t master_;
  uint32_t epoch_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class KeyMasterMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.KeyMasterMetadata) */ {
 public:
  inline KeyMasterMetadata() : KeyMasterMetadata(nullptr) {}
  ~KeyMasterMetadata() override;
  explicit PROTOBUF_CONSTEXPR KeyMasterMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyMasterMetadata(const KeyMasterMetadata& from);
  KeyMasterMetadata(KeyMasterMetadata&& from) noexcept
    : KeyMasterMetadata() {
    *this = ::std::move(from);
  }

  inline KeyMasterMetadata& operator=(const KeyMasterMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyMasterMetadata& operator=(KeyMasterMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyMasterMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyMasterMetadata* internal_default_instance() {
    return reinterpret_cast<const KeyMasterMetadata*>(
               &_KeyMasterMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KeyMasterMetadata& a, KeyMasterMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyMasterMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyMasterMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyMasterMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyMasterMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyMasterMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyMasterMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyMasterMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.KeyMasterMetadata";
  }
  protected:
  explicit KeyMasterMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .proto.MasterMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::proto::MasterMetadata& metadata() const;
  PROTOBUF_NODISCARD ::proto::MasterMetadata* release_metadata();
  ::proto::MasterMetadata* mutable_metadata();
  void set_allocated_metadata(::proto::MasterMetadata* metadata);
  private:
  const ::proto::MasterMetadata& _internal_metadata() const;
  ::proto::MasterMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::proto::MasterMetadata* metadata);
  ::proto::MasterMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:proto.KeyMasterMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::proto::MasterMetadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class LookupMasterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LookupMasterResponse) */ {
 public:
  inline LookupMasterResponse() : LookupMasterResponse(nullptr) {}
  ~LookupMasterResponse() override;
  explicit PROTOBUF_CONSTEXPR LookupMasterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupMasterResponse(const LookupMasterResponse& from);
  LookupMasterResponse(LookupMasterResponse&& from) noexcept
    : LookupMasterResponse() {
    *this = ::std::move(from);
  }

  inline LookupMasterResponse& operator=(const LookupMasterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupMasterResponse& operator=(LookupMasterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupMasterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupMasterResponse* internal_default_instance() {
    return reinterpret_cast<const LookupMasterResponse*>(
               &_LookupMasterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LookupMasterResponse& a, LookupMasterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupMasterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupMasterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupMasterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupMasterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupMasterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupMasterResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupMasterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LookupMasterResponse";
  }
  protected:
  explicit LookupMasterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochIdFieldNumber = 1,
    kLookupResultsFieldNumber = 2,
  };
  // repeated uint64 epoch_id = 1;
  int epoch_id_size() const;
  private:
  int _internal_epoch_id_size() const;
  public:
  void clear_epoch_id();
  private:
  uint64_t _internal_epoch_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_epoch_id() const;
  void _internal_add_epoch_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_epoch_id();
  public:
  uint64_t epoch_id(int index) const;
  void set_epoch_id(int index, uint64_t value);
  void add_epoch_id(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      epoch_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_epoch_id();

  // repeated .proto.KeyMasterMetadata lookup_results = 2;
  int lookup_results_size() const;
  private:
  int _internal_lookup_results_size() const;
  public:
  void clear_lookup_results();
  ::proto::KeyMasterMetadata* mutable_lookup_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::KeyMasterMetadata >*
      mutable_lookup_results();
  private:
  const ::proto::KeyMasterMetadata& _internal_lookup_results(int index) const;
  ::proto::KeyMasterMetadata* _internal_add_lookup_results();
  public:
  const ::proto::KeyMasterMetadata& lookup_results(int index) const;
  ::proto::KeyMasterMetadata* add_lookup_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::KeyMasterMetadata >&
      lookup_results() const;

  // @@protoc_insertion_point(class_scope:proto.LookupMasterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > epoch_id_;
  mutable std::atomic<int> _epoch_id_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::KeyMasterMetadata > lookup_results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftAcceptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftAcceptResponse) */ {
 public:
  inline RaftAcceptResponse() : RaftAcceptResponse(nullptr) {}
  ~RaftAcceptResponse() override;
  explicit PROTOBUF_CONSTEXPR RaftAcceptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftAcceptResponse(const RaftAcceptResponse& from);
  RaftAcceptResponse(RaftAcceptResponse&& from) noexcept
    : RaftAcceptResponse() {
    *this = ::std::move(from);
  }

  inline RaftAcceptResponse& operator=(const RaftAcceptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftAcceptResponse& operator=(RaftAcceptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftAcceptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftAcceptResponse* internal_default_instance() {
    return reinterpret_cast<const RaftAcceptResponse*>(
               &_RaftAcceptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RaftAcceptResponse& a, RaftAcceptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftAcceptResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftAcceptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftAcceptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftAcceptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftAcceptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftAcceptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftAcceptResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftAcceptResponse";
  }
  protected:
  explicit RaftAcceptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // uint32 result = 4;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RaftAcceptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint64_t epoch_id_;
  uint32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RaftCommitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RaftCommitResponse) */ {
 public:
  inline RaftCommitResponse() : RaftCommitResponse(nullptr) {}
  ~RaftCommitResponse() override;
  explicit PROTOBUF_CONSTEXPR RaftCommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftCommitResponse(const RaftCommitResponse& from);
  RaftCommitResponse(RaftCommitResponse&& from) noexcept
    : RaftCommitResponse() {
    *this = ::std::move(from);
  }

  inline RaftCommitResponse& operator=(const RaftCommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftCommitResponse& operator=(RaftCommitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftCommitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftCommitResponse* internal_default_instance() {
    return reinterpret_cast<const RaftCommitResponse*>(
               &_RaftCommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RaftCommitResponse& a, RaftCommitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftCommitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftCommitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftCommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftCommitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftCommitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RaftCommitResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftCommitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RaftCommitResponse";
  }
  protected:
  explicit RaftCommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
    kResultFieldNumber = 4,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // uint32 result = 4;
  void clear_result();
  uint32_t result() const;
  void set_result(uint32_t value);
  private:
  uint32_t _internal_result() const;
  void _internal_set_result(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RaftCommitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint64_t epoch_id_;
  uint32_t result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class StatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.StatsResponse) */ {
 public:
  inline StatsResponse() : StatsResponse(nullptr) {}
  ~StatsResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsResponse(const StatsResponse& from);
  StatsResponse(StatsResponse&& from) noexcept
    : StatsResponse() {
    *this = ::std::move(from);
  }

  inline StatsResponse& operator=(const StatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsResponse& operator=(StatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsResponse* internal_default_instance() {
    return reinterpret_cast<const StatsResponse*>(
               &_StatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StatsResponse& a, StatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.StatsResponse";
  }
  protected:
  explicit StatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 3,
    kFromFieldNumber = 1,
  };
  // uint64 to = 2;
  void clear_to();
  uint64_t to() const;
  void set_to(uint64_t value);
  private:
  uint64_t _internal_to() const;
  void _internal_set_to(uint64_t value);
  public:

  // uint64 epoch_id = 3;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.StatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t to_;
  uint64_t epoch_id_;
  uint32_t from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// -------------------------------------------------------------------

class ChangeServerStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ChangeServerStateResponse) */ {
 public:
  inline ChangeServerStateResponse() : ChangeServerStateResponse(nullptr) {}
  ~ChangeServerStateResponse() override;
  explicit PROTOBUF_CONSTEXPR ChangeServerStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeServerStateResponse(const ChangeServerStateResponse& from);
  ChangeServerStateResponse(ChangeServerStateResponse&& from) noexcept
    : ChangeServerStateResponse() {
    *this = ::std::move(from);
  }

  inline ChangeServerStateResponse& operator=(const ChangeServerStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeServerStateResponse& operator=(ChangeServerStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeServerStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeServerStateResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeServerStateResponse*>(
               &_ChangeServerStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ChangeServerStateResponse& a, ChangeServerStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeServerStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeServerStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeServerStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeServerStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeServerStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeServerStateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeServerStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ChangeServerStateResponse";
  }
  protected:
  explicit ChangeServerStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kEpochIdFieldNumber = 4,
    kTargetFieldNumber = 3,
    kStateFieldNumber = 5,
  };
  // uint32 from = 1;
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // uint32 to = 2;
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // uint64 epoch_id = 4;
  void clear_epoch_id();
  uint64_t epoch_id() const;
  void set_epoch_id(uint64_t value);
  private:
  uint64_t _internal_epoch_id() const;
  void _internal_set_epoch_id(uint64_t value);
  public:

  // uint32 target = 3;
  void clear_target();
  uint32_t target() const;
  void set_target(uint32_t value);
  private:
  uint32_t _internal_target() const;
  void _internal_set_target(uint32_t value);
  public:

  // uint32 state = 5;
  void clear_state();
  uint32_t state() const;
  void set_state(uint32_t value);
  private:
  uint32_t _internal_state() const;
  void _internal_set_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ChangeServerStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t from_;
  uint32_t to_;
  uint64_t epoch_id_;
  uint32_t target_;
  uint32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReplyTransactionToClient

// uint64 client_txn_id = 1;
inline void ReplyTransactionToClient::clear_client_txn_id() {
  client_txn_id_ = uint64_t{0u};
}
inline uint64_t ReplyTransactionToClient::_internal_client_txn_id() const {
  return client_txn_id_;
}
inline uint64_t ReplyTransactionToClient::client_txn_id() const {
  // @@protoc_insertion_point(field_get:proto.ReplyTransactionToClient.client_txn_id)
  return _internal_client_txn_id();
}
inline void ReplyTransactionToClient::_internal_set_client_txn_id(uint64_t value) {
  
  client_txn_id_ = value;
}
inline void ReplyTransactionToClient::set_client_txn_id(uint64_t value) {
  _internal_set_client_txn_id(value);
  // @@protoc_insertion_point(field_set:proto.ReplyTransactionToClient.client_txn_id)
}

// .proto.TxnState txn_state = 2;
inline void ReplyTransactionToClient::clear_txn_state() {
  txn_state_ = 0;
}
inline ::proto::TxnState ReplyTransactionToClient::_internal_txn_state() const {
  return static_cast< ::proto::TxnState >(txn_state_);
}
inline ::proto::TxnState ReplyTransactionToClient::txn_state() const {
  // @@protoc_insertion_point(field_get:proto.ReplyTransactionToClient.txn_state)
  return _internal_txn_state();
}
inline void ReplyTransactionToClient::_internal_set_txn_state(::proto::TxnState value) {
  
  txn_state_ = value;
}
inline void ReplyTransactionToClient::set_txn_state(::proto::TxnState value) {
  _internal_set_txn_state(value);
  // @@protoc_insertion_point(field_set:proto.ReplyTransactionToClient.txn_state)
}

// .proto.Node send_node = 3;
inline bool ReplyTransactionToClient::_internal_has_send_node() const {
  return this != internal_default_instance() && send_node_ != nullptr;
}
inline bool ReplyTransactionToClient::has_send_node() const {
  return _internal_has_send_node();
}
inline const ::proto::Node& ReplyTransactionToClient::_internal_send_node() const {
  const ::proto::Node* p = send_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Node&>(
      ::proto::_Node_default_instance_);
}
inline const ::proto::Node& ReplyTransactionToClient::send_node() const {
  // @@protoc_insertion_point(field_get:proto.ReplyTransactionToClient.send_node)
  return _internal_send_node();
}
inline void ReplyTransactionToClient::unsafe_arena_set_allocated_send_node(
    ::proto::Node* send_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_node_);
  }
  send_node_ = send_node;
  if (send_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ReplyTransactionToClient.send_node)
}
inline ::proto::Node* ReplyTransactionToClient::release_send_node() {
  
  ::proto::Node* temp = send_node_;
  send_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Node* ReplyTransactionToClient::unsafe_arena_release_send_node() {
  // @@protoc_insertion_point(field_release:proto.ReplyTransactionToClient.send_node)
  
  ::proto::Node* temp = send_node_;
  send_node_ = nullptr;
  return temp;
}
inline ::proto::Node* ReplyTransactionToClient::_internal_mutable_send_node() {
  
  if (send_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Node>(GetArenaForAllocation());
    send_node_ = p;
  }
  return send_node_;
}
inline ::proto::Node* ReplyTransactionToClient::mutable_send_node() {
  ::proto::Node* _msg = _internal_mutable_send_node();
  // @@protoc_insertion_point(field_mutable:proto.ReplyTransactionToClient.send_node)
  return _msg;
}
inline void ReplyTransactionToClient::set_allocated_send_node(::proto::Node* send_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_node_);
  }
  if (send_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_node));
    if (message_arena != submessage_arena) {
      send_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_node, submessage_arena);
    }
    
  } else {
    
  }
  send_node_ = send_node;
  // @@protoc_insertion_point(field_set_allocated:proto.ReplyTransactionToClient.send_node)
}

// .proto.Node recv_node = 4;
inline bool ReplyTransactionToClient::_internal_has_recv_node() const {
  return this != internal_default_instance() && recv_node_ != nullptr;
}
inline bool ReplyTransactionToClient::has_recv_node() const {
  return _internal_has_recv_node();
}
inline const ::proto::Node& ReplyTransactionToClient::_internal_recv_node() const {
  const ::proto::Node* p = recv_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::Node&>(
      ::proto::_Node_default_instance_);
}
inline const ::proto::Node& ReplyTransactionToClient::recv_node() const {
  // @@protoc_insertion_point(field_get:proto.ReplyTransactionToClient.recv_node)
  return _internal_recv_node();
}
inline void ReplyTransactionToClient::unsafe_arena_set_allocated_recv_node(
    ::proto::Node* recv_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recv_node_);
  }
  recv_node_ = recv_node;
  if (recv_node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.ReplyTransactionToClient.recv_node)
}
inline ::proto::Node* ReplyTransactionToClient::release_recv_node() {
  
  ::proto::Node* temp = recv_node_;
  recv_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::Node* ReplyTransactionToClient::unsafe_arena_release_recv_node() {
  // @@protoc_insertion_point(field_release:proto.ReplyTransactionToClient.recv_node)
  
  ::proto::Node* temp = recv_node_;
  recv_node_ = nullptr;
  return temp;
}
inline ::proto::Node* ReplyTransactionToClient::_internal_mutable_recv_node() {
  
  if (recv_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::Node>(GetArenaForAllocation());
    recv_node_ = p;
  }
  return recv_node_;
}
inline ::proto::Node* ReplyTransactionToClient::mutable_recv_node() {
  ::proto::Node* _msg = _internal_mutable_recv_node();
  // @@protoc_insertion_point(field_mutable:proto.ReplyTransactionToClient.recv_node)
  return _msg;
}
inline void ReplyTransactionToClient::set_allocated_recv_node(::proto::Node* recv_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(recv_node_);
  }
  if (recv_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recv_node));
    if (message_arena != submessage_arena) {
      recv_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recv_node, submessage_arena);
    }
    
  } else {
    
  }
  recv_node_ = recv_node;
  // @@protoc_insertion_point(field_set_allocated:proto.ReplyTransactionToClient.recv_node)
}

// -------------------------------------------------------------------

// RaftRequest

// .proto.Ping ping = 1;
inline bool RaftRequest::_internal_has_ping() const {
  return type_case() == kPing;
}
inline bool RaftRequest::has_ping() const {
  return _internal_has_ping();
}
inline void RaftRequest::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void RaftRequest::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.ping_;
    }
    clear_has_type();
  }
}
inline ::proto::Ping* RaftRequest::release_ping() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.ping)
  if (_internal_has_ping()) {
    clear_has_type();
    ::proto::Ping* temp = type_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Ping& RaftRequest::_internal_ping() const {
  return _internal_has_ping()
      ? *type_.ping_
      : reinterpret_cast< ::proto::Ping&>(::proto::_Ping_default_instance_);
}
inline const ::proto::Ping& RaftRequest::ping() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.ping)
  return _internal_ping();
}
inline ::proto::Ping* RaftRequest::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.ping)
  if (_internal_has_ping()) {
    clear_has_type();
    ::proto::Ping* temp = type_.ping_;
    type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_ping(::proto::Ping* ping) {
  clear_type();
  if (ping) {
    set_has_ping();
    type_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.ping)
}
inline ::proto::Ping* RaftRequest::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_type();
    set_has_ping();
    type_.ping_ = CreateMaybeMessage< ::proto::Ping >(GetArenaForAllocation());
  }
  return type_.ping_;
}
inline ::proto::Ping* RaftRequest::mutable_ping() {
  ::proto::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.ping)
  return _msg;
}

// .proto.Signal signal = 2;
inline bool RaftRequest::_internal_has_signal() const {
  return type_case() == kSignal;
}
inline bool RaftRequest::has_signal() const {
  return _internal_has_signal();
}
inline void RaftRequest::set_has_signal() {
  _oneof_case_[0] = kSignal;
}
inline void RaftRequest::clear_signal() {
  if (_internal_has_signal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.signal_;
    }
    clear_has_type();
  }
}
inline ::proto::Signal* RaftRequest::release_signal() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.signal)
  if (_internal_has_signal()) {
    clear_has_type();
    ::proto::Signal* temp = type_.signal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Signal& RaftRequest::_internal_signal() const {
  return _internal_has_signal()
      ? *type_.signal_
      : reinterpret_cast< ::proto::Signal&>(::proto::_Signal_default_instance_);
}
inline const ::proto::Signal& RaftRequest::signal() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.signal)
  return _internal_signal();
}
inline ::proto::Signal* RaftRequest::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.signal)
  if (_internal_has_signal()) {
    clear_has_type();
    ::proto::Signal* temp = type_.signal_;
    type_.signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_signal(::proto::Signal* signal) {
  clear_type();
  if (signal) {
    set_has_signal();
    type_.signal_ = signal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.signal)
}
inline ::proto::Signal* RaftRequest::_internal_mutable_signal() {
  if (!_internal_has_signal()) {
    clear_type();
    set_has_signal();
    type_.signal_ = CreateMaybeMessage< ::proto::Signal >(GetArenaForAllocation());
  }
  return type_.signal_;
}
inline ::proto::Signal* RaftRequest::mutable_signal() {
  ::proto::Signal* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.signal)
  return _msg;
}

// .proto.LookupMasterRequest lookup_master = 3;
inline bool RaftRequest::_internal_has_lookup_master() const {
  return type_case() == kLookupMaster;
}
inline bool RaftRequest::has_lookup_master() const {
  return _internal_has_lookup_master();
}
inline void RaftRequest::set_has_lookup_master() {
  _oneof_case_[0] = kLookupMaster;
}
inline void RaftRequest::clear_lookup_master() {
  if (_internal_has_lookup_master()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.lookup_master_;
    }
    clear_has_type();
  }
}
inline ::proto::LookupMasterRequest* RaftRequest::release_lookup_master() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.lookup_master)
  if (_internal_has_lookup_master()) {
    clear_has_type();
    ::proto::LookupMasterRequest* temp = type_.lookup_master_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.lookup_master_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::LookupMasterRequest& RaftRequest::_internal_lookup_master() const {
  return _internal_has_lookup_master()
      ? *type_.lookup_master_
      : reinterpret_cast< ::proto::LookupMasterRequest&>(::proto::_LookupMasterRequest_default_instance_);
}
inline const ::proto::LookupMasterRequest& RaftRequest::lookup_master() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.lookup_master)
  return _internal_lookup_master();
}
inline ::proto::LookupMasterRequest* RaftRequest::unsafe_arena_release_lookup_master() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.lookup_master)
  if (_internal_has_lookup_master()) {
    clear_has_type();
    ::proto::LookupMasterRequest* temp = type_.lookup_master_;
    type_.lookup_master_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_lookup_master(::proto::LookupMasterRequest* lookup_master) {
  clear_type();
  if (lookup_master) {
    set_has_lookup_master();
    type_.lookup_master_ = lookup_master;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.lookup_master)
}
inline ::proto::LookupMasterRequest* RaftRequest::_internal_mutable_lookup_master() {
  if (!_internal_has_lookup_master()) {
    clear_type();
    set_has_lookup_master();
    type_.lookup_master_ = CreateMaybeMessage< ::proto::LookupMasterRequest >(GetArenaForAllocation());
  }
  return type_.lookup_master_;
}
inline ::proto::LookupMasterRequest* RaftRequest::mutable_lookup_master() {
  ::proto::LookupMasterRequest* _msg = _internal_mutable_lookup_master();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.lookup_master)
  return _msg;
}

// .proto.ForwardEpochRequest forward_epoch = 4;
inline bool RaftRequest::_internal_has_forward_epoch() const {
  return type_case() == kForwardEpoch;
}
inline bool RaftRequest::has_forward_epoch() const {
  return _internal_has_forward_epoch();
}
inline void RaftRequest::set_has_forward_epoch() {
  _oneof_case_[0] = kForwardEpoch;
}
inline void RaftRequest::clear_forward_epoch() {
  if (_internal_has_forward_epoch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.forward_epoch_;
    }
    clear_has_type();
  }
}
inline ::proto::ForwardEpochRequest* RaftRequest::release_forward_epoch() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.forward_epoch)
  if (_internal_has_forward_epoch()) {
    clear_has_type();
    ::proto::ForwardEpochRequest* temp = type_.forward_epoch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.forward_epoch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ForwardEpochRequest& RaftRequest::_internal_forward_epoch() const {
  return _internal_has_forward_epoch()
      ? *type_.forward_epoch_
      : reinterpret_cast< ::proto::ForwardEpochRequest&>(::proto::_ForwardEpochRequest_default_instance_);
}
inline const ::proto::ForwardEpochRequest& RaftRequest::forward_epoch() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.forward_epoch)
  return _internal_forward_epoch();
}
inline ::proto::ForwardEpochRequest* RaftRequest::unsafe_arena_release_forward_epoch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.forward_epoch)
  if (_internal_has_forward_epoch()) {
    clear_has_type();
    ::proto::ForwardEpochRequest* temp = type_.forward_epoch_;
    type_.forward_epoch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_forward_epoch(::proto::ForwardEpochRequest* forward_epoch) {
  clear_type();
  if (forward_epoch) {
    set_has_forward_epoch();
    type_.forward_epoch_ = forward_epoch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.forward_epoch)
}
inline ::proto::ForwardEpochRequest* RaftRequest::_internal_mutable_forward_epoch() {
  if (!_internal_has_forward_epoch()) {
    clear_type();
    set_has_forward_epoch();
    type_.forward_epoch_ = CreateMaybeMessage< ::proto::ForwardEpochRequest >(GetArenaForAllocation());
  }
  return type_.forward_epoch_;
}
inline ::proto::ForwardEpochRequest* RaftRequest::mutable_forward_epoch() {
  ::proto::ForwardEpochRequest* _msg = _internal_mutable_forward_epoch();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.forward_epoch)
  return _msg;
}

// .proto.EpochReplicationAck epoch_replication_ack = 5;
inline bool RaftRequest::_internal_has_epoch_replication_ack() const {
  return type_case() == kEpochReplicationAck;
}
inline bool RaftRequest::has_epoch_replication_ack() const {
  return _internal_has_epoch_replication_ack();
}
inline void RaftRequest::set_has_epoch_replication_ack() {
  _oneof_case_[0] = kEpochReplicationAck;
}
inline void RaftRequest::clear_epoch_replication_ack() {
  if (_internal_has_epoch_replication_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.epoch_replication_ack_;
    }
    clear_has_type();
  }
}
inline ::proto::EpochReplicationAck* RaftRequest::release_epoch_replication_ack() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.epoch_replication_ack)
  if (_internal_has_epoch_replication_ack()) {
    clear_has_type();
    ::proto::EpochReplicationAck* temp = type_.epoch_replication_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.epoch_replication_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::EpochReplicationAck& RaftRequest::_internal_epoch_replication_ack() const {
  return _internal_has_epoch_replication_ack()
      ? *type_.epoch_replication_ack_
      : reinterpret_cast< ::proto::EpochReplicationAck&>(::proto::_EpochReplicationAck_default_instance_);
}
inline const ::proto::EpochReplicationAck& RaftRequest::epoch_replication_ack() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.epoch_replication_ack)
  return _internal_epoch_replication_ack();
}
inline ::proto::EpochReplicationAck* RaftRequest::unsafe_arena_release_epoch_replication_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.epoch_replication_ack)
  if (_internal_has_epoch_replication_ack()) {
    clear_has_type();
    ::proto::EpochReplicationAck* temp = type_.epoch_replication_ack_;
    type_.epoch_replication_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_epoch_replication_ack(::proto::EpochReplicationAck* epoch_replication_ack) {
  clear_type();
  if (epoch_replication_ack) {
    set_has_epoch_replication_ack();
    type_.epoch_replication_ack_ = epoch_replication_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.epoch_replication_ack)
}
inline ::proto::EpochReplicationAck* RaftRequest::_internal_mutable_epoch_replication_ack() {
  if (!_internal_has_epoch_replication_ack()) {
    clear_type();
    set_has_epoch_replication_ack();
    type_.epoch_replication_ack_ = CreateMaybeMessage< ::proto::EpochReplicationAck >(GetArenaForAllocation());
  }
  return type_.epoch_replication_ack_;
}
inline ::proto::EpochReplicationAck* RaftRequest::mutable_epoch_replication_ack() {
  ::proto::EpochReplicationAck* _msg = _internal_mutable_epoch_replication_ack();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.epoch_replication_ack)
  return _msg;
}

// .proto.RaftPropose raft_propose = 6;
inline bool RaftRequest::_internal_has_raft_propose() const {
  return type_case() == kRaftPropose;
}
inline bool RaftRequest::has_raft_propose() const {
  return _internal_has_raft_propose();
}
inline void RaftRequest::set_has_raft_propose() {
  _oneof_case_[0] = kRaftPropose;
}
inline void RaftRequest::clear_raft_propose() {
  if (_internal_has_raft_propose()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.raft_propose_;
    }
    clear_has_type();
  }
}
inline ::proto::RaftPropose* RaftRequest::release_raft_propose() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.raft_propose)
  if (_internal_has_raft_propose()) {
    clear_has_type();
    ::proto::RaftPropose* temp = type_.raft_propose_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.raft_propose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::RaftPropose& RaftRequest::_internal_raft_propose() const {
  return _internal_has_raft_propose()
      ? *type_.raft_propose_
      : reinterpret_cast< ::proto::RaftPropose&>(::proto::_RaftPropose_default_instance_);
}
inline const ::proto::RaftPropose& RaftRequest::raft_propose() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.raft_propose)
  return _internal_raft_propose();
}
inline ::proto::RaftPropose* RaftRequest::unsafe_arena_release_raft_propose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.raft_propose)
  if (_internal_has_raft_propose()) {
    clear_has_type();
    ::proto::RaftPropose* temp = type_.raft_propose_;
    type_.raft_propose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_raft_propose(::proto::RaftPropose* raft_propose) {
  clear_type();
  if (raft_propose) {
    set_has_raft_propose();
    type_.raft_propose_ = raft_propose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.raft_propose)
}
inline ::proto::RaftPropose* RaftRequest::_internal_mutable_raft_propose() {
  if (!_internal_has_raft_propose()) {
    clear_type();
    set_has_raft_propose();
    type_.raft_propose_ = CreateMaybeMessage< ::proto::RaftPropose >(GetArenaForAllocation());
  }
  return type_.raft_propose_;
}
inline ::proto::RaftPropose* RaftRequest::mutable_raft_propose() {
  ::proto::RaftPropose* _msg = _internal_mutable_raft_propose();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.raft_propose)
  return _msg;
}

// .proto.RaftAcceptRequest raft_accept = 7;
inline bool RaftRequest::_internal_has_raft_accept() const {
  return type_case() == kRaftAccept;
}
inline bool RaftRequest::has_raft_accept() const {
  return _internal_has_raft_accept();
}
inline void RaftRequest::set_has_raft_accept() {
  _oneof_case_[0] = kRaftAccept;
}
inline void RaftRequest::clear_raft_accept() {
  if (_internal_has_raft_accept()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.raft_accept_;
    }
    clear_has_type();
  }
}
inline ::proto::RaftAcceptRequest* RaftRequest::release_raft_accept() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.raft_accept)
  if (_internal_has_raft_accept()) {
    clear_has_type();
    ::proto::RaftAcceptRequest* temp = type_.raft_accept_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.raft_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::RaftAcceptRequest& RaftRequest::_internal_raft_accept() const {
  return _internal_has_raft_accept()
      ? *type_.raft_accept_
      : reinterpret_cast< ::proto::RaftAcceptRequest&>(::proto::_RaftAcceptRequest_default_instance_);
}
inline const ::proto::RaftAcceptRequest& RaftRequest::raft_accept() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.raft_accept)
  return _internal_raft_accept();
}
inline ::proto::RaftAcceptRequest* RaftRequest::unsafe_arena_release_raft_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.raft_accept)
  if (_internal_has_raft_accept()) {
    clear_has_type();
    ::proto::RaftAcceptRequest* temp = type_.raft_accept_;
    type_.raft_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_raft_accept(::proto::RaftAcceptRequest* raft_accept) {
  clear_type();
  if (raft_accept) {
    set_has_raft_accept();
    type_.raft_accept_ = raft_accept;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.raft_accept)
}
inline ::proto::RaftAcceptRequest* RaftRequest::_internal_mutable_raft_accept() {
  if (!_internal_has_raft_accept()) {
    clear_type();
    set_has_raft_accept();
    type_.raft_accept_ = CreateMaybeMessage< ::proto::RaftAcceptRequest >(GetArenaForAllocation());
  }
  return type_.raft_accept_;
}
inline ::proto::RaftAcceptRequest* RaftRequest::mutable_raft_accept() {
  ::proto::RaftAcceptRequest* _msg = _internal_mutable_raft_accept();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.raft_accept)
  return _msg;
}

// .proto.RaftCommitRequest raft_commit = 8;
inline bool RaftRequest::_internal_has_raft_commit() const {
  return type_case() == kRaftCommit;
}
inline bool RaftRequest::has_raft_commit() const {
  return _internal_has_raft_commit();
}
inline void RaftRequest::set_has_raft_commit() {
  _oneof_case_[0] = kRaftCommit;
}
inline void RaftRequest::clear_raft_commit() {
  if (_internal_has_raft_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.raft_commit_;
    }
    clear_has_type();
  }
}
inline ::proto::RaftCommitRequest* RaftRequest::release_raft_commit() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.raft_commit)
  if (_internal_has_raft_commit()) {
    clear_has_type();
    ::proto::RaftCommitRequest* temp = type_.raft_commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.raft_commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::RaftCommitRequest& RaftRequest::_internal_raft_commit() const {
  return _internal_has_raft_commit()
      ? *type_.raft_commit_
      : reinterpret_cast< ::proto::RaftCommitRequest&>(::proto::_RaftCommitRequest_default_instance_);
}
inline const ::proto::RaftCommitRequest& RaftRequest::raft_commit() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.raft_commit)
  return _internal_raft_commit();
}
inline ::proto::RaftCommitRequest* RaftRequest::unsafe_arena_release_raft_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.raft_commit)
  if (_internal_has_raft_commit()) {
    clear_has_type();
    ::proto::RaftCommitRequest* temp = type_.raft_commit_;
    type_.raft_commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_raft_commit(::proto::RaftCommitRequest* raft_commit) {
  clear_type();
  if (raft_commit) {
    set_has_raft_commit();
    type_.raft_commit_ = raft_commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.raft_commit)
}
inline ::proto::RaftCommitRequest* RaftRequest::_internal_mutable_raft_commit() {
  if (!_internal_has_raft_commit()) {
    clear_type();
    set_has_raft_commit();
    type_.raft_commit_ = CreateMaybeMessage< ::proto::RaftCommitRequest >(GetArenaForAllocation());
  }
  return type_.raft_commit_;
}
inline ::proto::RaftCommitRequest* RaftRequest::mutable_raft_commit() {
  ::proto::RaftCommitRequest* _msg = _internal_mutable_raft_commit();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.raft_commit)
  return _msg;
}

// .proto.StatsRequest stats = 9;
inline bool RaftRequest::_internal_has_stats() const {
  return type_case() == kStats;
}
inline bool RaftRequest::has_stats() const {
  return _internal_has_stats();
}
inline void RaftRequest::set_has_stats() {
  _oneof_case_[0] = kStats;
}
inline void RaftRequest::clear_stats() {
  if (_internal_has_stats()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.stats_;
    }
    clear_has_type();
  }
}
inline ::proto::StatsRequest* RaftRequest::release_stats() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.stats)
  if (_internal_has_stats()) {
    clear_has_type();
    ::proto::StatsRequest* temp = type_.stats_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::StatsRequest& RaftRequest::_internal_stats() const {
  return _internal_has_stats()
      ? *type_.stats_
      : reinterpret_cast< ::proto::StatsRequest&>(::proto::_StatsRequest_default_instance_);
}
inline const ::proto::StatsRequest& RaftRequest::stats() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.stats)
  return _internal_stats();
}
inline ::proto::StatsRequest* RaftRequest::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.stats)
  if (_internal_has_stats()) {
    clear_has_type();
    ::proto::StatsRequest* temp = type_.stats_;
    type_.stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_stats(::proto::StatsRequest* stats) {
  clear_type();
  if (stats) {
    set_has_stats();
    type_.stats_ = stats;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.stats)
}
inline ::proto::StatsRequest* RaftRequest::_internal_mutable_stats() {
  if (!_internal_has_stats()) {
    clear_type();
    set_has_stats();
    type_.stats_ = CreateMaybeMessage< ::proto::StatsRequest >(GetArenaForAllocation());
  }
  return type_.stats_;
}
inline ::proto::StatsRequest* RaftRequest::mutable_stats() {
  ::proto::StatsRequest* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.stats)
  return _msg;
}

// .proto.ChangeServerStateRequest change_server_state = 10;
inline bool RaftRequest::_internal_has_change_server_state() const {
  return type_case() == kChangeServerState;
}
inline bool RaftRequest::has_change_server_state() const {
  return _internal_has_change_server_state();
}
inline void RaftRequest::set_has_change_server_state() {
  _oneof_case_[0] = kChangeServerState;
}
inline void RaftRequest::clear_change_server_state() {
  if (_internal_has_change_server_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.change_server_state_;
    }
    clear_has_type();
  }
}
inline ::proto::ChangeServerStateRequest* RaftRequest::release_change_server_state() {
  // @@protoc_insertion_point(field_release:proto.RaftRequest.change_server_state)
  if (_internal_has_change_server_state()) {
    clear_has_type();
    ::proto::ChangeServerStateRequest* temp = type_.change_server_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.change_server_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ChangeServerStateRequest& RaftRequest::_internal_change_server_state() const {
  return _internal_has_change_server_state()
      ? *type_.change_server_state_
      : reinterpret_cast< ::proto::ChangeServerStateRequest&>(::proto::_ChangeServerStateRequest_default_instance_);
}
inline const ::proto::ChangeServerStateRequest& RaftRequest::change_server_state() const {
  // @@protoc_insertion_point(field_get:proto.RaftRequest.change_server_state)
  return _internal_change_server_state();
}
inline ::proto::ChangeServerStateRequest* RaftRequest::unsafe_arena_release_change_server_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftRequest.change_server_state)
  if (_internal_has_change_server_state()) {
    clear_has_type();
    ::proto::ChangeServerStateRequest* temp = type_.change_server_state_;
    type_.change_server_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftRequest::unsafe_arena_set_allocated_change_server_state(::proto::ChangeServerStateRequest* change_server_state) {
  clear_type();
  if (change_server_state) {
    set_has_change_server_state();
    type_.change_server_state_ = change_server_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftRequest.change_server_state)
}
inline ::proto::ChangeServerStateRequest* RaftRequest::_internal_mutable_change_server_state() {
  if (!_internal_has_change_server_state()) {
    clear_type();
    set_has_change_server_state();
    type_.change_server_state_ = CreateMaybeMessage< ::proto::ChangeServerStateRequest >(GetArenaForAllocation());
  }
  return type_.change_server_state_;
}
inline ::proto::ChangeServerStateRequest* RaftRequest::mutable_change_server_state() {
  ::proto::ChangeServerStateRequest* _msg = _internal_mutable_change_server_state();
  // @@protoc_insertion_point(field_mutable:proto.RaftRequest.change_server_state)
  return _msg;
}

inline bool RaftRequest::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RaftRequest::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline RaftRequest::TypeCase RaftRequest::type_case() const {
  return RaftRequest::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ping

// int32 from = 1;
inline void Ping::clear_from() {
  from_ = 0;
}
inline int32_t Ping::_internal_from() const {
  return from_;
}
inline int32_t Ping::from() const {
  // @@protoc_insertion_point(field_get:proto.Ping.from)
  return _internal_from();
}
inline void Ping::_internal_set_from(int32_t value) {
  
  from_ = value;
}
inline void Ping::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Ping.from)
}

// int32 to = 2;
inline void Ping::clear_to() {
  to_ = 0;
}
inline int32_t Ping::_internal_to() const {
  return to_;
}
inline int32_t Ping::to() const {
  // @@protoc_insertion_point(field_get:proto.Ping.to)
  return _internal_to();
}
inline void Ping::_internal_set_to(int32_t value) {
  
  to_ = value;
}
inline void Ping::set_to(int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.Ping.to)
}

// -------------------------------------------------------------------

// Signal

// int32 from = 1;
inline void Signal::clear_from() {
  from_ = 0;
}
inline int32_t Signal::_internal_from() const {
  return from_;
}
inline int32_t Signal::from() const {
  // @@protoc_insertion_point(field_get:proto.Signal.from)
  return _internal_from();
}
inline void Signal::_internal_set_from(int32_t value) {
  
  from_ = value;
}
inline void Signal::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Signal.from)
}

// -------------------------------------------------------------------

// LookupMasterRequest

// repeated uint64 txn_ids = 1;
inline int LookupMasterRequest::_internal_txn_ids_size() const {
  return txn_ids_.size();
}
inline int LookupMasterRequest::txn_ids_size() const {
  return _internal_txn_ids_size();
}
inline void LookupMasterRequest::clear_txn_ids() {
  txn_ids_.Clear();
}
inline uint64_t LookupMasterRequest::_internal_txn_ids(int index) const {
  return txn_ids_.Get(index);
}
inline uint64_t LookupMasterRequest::txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:proto.LookupMasterRequest.txn_ids)
  return _internal_txn_ids(index);
}
inline void LookupMasterRequest::set_txn_ids(int index, uint64_t value) {
  txn_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.LookupMasterRequest.txn_ids)
}
inline void LookupMasterRequest::_internal_add_txn_ids(uint64_t value) {
  txn_ids_.Add(value);
}
inline void LookupMasterRequest::add_txn_ids(uint64_t value) {
  _internal_add_txn_ids(value);
  // @@protoc_insertion_point(field_add:proto.LookupMasterRequest.txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LookupMasterRequest::_internal_txn_ids() const {
  return txn_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LookupMasterRequest::txn_ids() const {
  // @@protoc_insertion_point(field_list:proto.LookupMasterRequest.txn_ids)
  return _internal_txn_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LookupMasterRequest::_internal_mutable_txn_ids() {
  return &txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LookupMasterRequest::mutable_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:proto.LookupMasterRequest.txn_ids)
  return _internal_mutable_txn_ids();
}

// repeated bytes keys = 2;
inline int LookupMasterRequest::_internal_keys_size() const {
  return keys_.size();
}
inline int LookupMasterRequest::keys_size() const {
  return _internal_keys_size();
}
inline void LookupMasterRequest::clear_keys() {
  keys_.Clear();
}
inline std::string* LookupMasterRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:proto.LookupMasterRequest.keys)
  return _s;
}
inline const std::string& LookupMasterRequest::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& LookupMasterRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:proto.LookupMasterRequest.keys)
  return _internal_keys(index);
}
inline std::string* LookupMasterRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:proto.LookupMasterRequest.keys)
  return keys_.Mutable(index);
}
inline void LookupMasterRequest::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.LookupMasterRequest.keys)
}
inline std::string* LookupMasterRequest::_internal_add_keys() {
  return keys_.Add();
}
inline void LookupMasterRequest::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.LookupMasterRequest.keys)
}
inline void LookupMasterRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.LookupMasterRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LookupMasterRequest::keys() const {
  // @@protoc_insertion_point(field_list:proto.LookupMasterRequest.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LookupMasterRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:proto.LookupMasterRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// ForwardEpochRequest

// int32 from = 1;
inline void ForwardEpochRequest::clear_from() {
  from_ = 0;
}
inline int32_t ForwardEpochRequest::_internal_from() const {
  return from_;
}
inline int32_t ForwardEpochRequest::from() const {
  // @@protoc_insertion_point(field_get:proto.ForwardEpochRequest.from)
  return _internal_from();
}
inline void ForwardEpochRequest::_internal_set_from(int32_t value) {
  
  from_ = value;
}
inline void ForwardEpochRequest::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.ForwardEpochRequest.from)
}

// int32 to = 2;
inline void ForwardEpochRequest::clear_to() {
  to_ = 0;
}
inline int32_t ForwardEpochRequest::_internal_to() const {
  return to_;
}
inline int32_t ForwardEpochRequest::to() const {
  // @@protoc_insertion_point(field_get:proto.ForwardEpochRequest.to)
  return _internal_to();
}
inline void ForwardEpochRequest::_internal_set_to(int32_t value) {
  
  to_ = value;
}
inline void ForwardEpochRequest::set_to(int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.ForwardEpochRequest.to)
}

// uint64 epoch_id = 3;
inline void ForwardEpochRequest::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t ForwardEpochRequest::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t ForwardEpochRequest::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.ForwardEpochRequest.epoch_id)
  return _internal_epoch_id();
}
inline void ForwardEpochRequest::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void ForwardEpochRequest::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.ForwardEpochRequest.epoch_id)
}

// -------------------------------------------------------------------

// EpochReplicationAck

// uint64 epoch_id = 1;
inline void EpochReplicationAck::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t EpochReplicationAck::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t EpochReplicationAck::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.EpochReplicationAck.epoch_id)
  return _internal_epoch_id();
}
inline void EpochReplicationAck::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void EpochReplicationAck::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.EpochReplicationAck.epoch_id)
}

// -------------------------------------------------------------------

// RaftPropose

// uint64 value = 1;
inline void RaftPropose::clear_value() {
  value_ = uint64_t{0u};
}
inline uint64_t RaftPropose::_internal_value() const {
  return value_;
}
inline uint64_t RaftPropose::value() const {
  // @@protoc_insertion_point(field_get:proto.RaftPropose.value)
  return _internal_value();
}
inline void RaftPropose::_internal_set_value(uint64_t value) {
  
  value_ = value;
}
inline void RaftPropose::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:proto.RaftPropose.value)
}

// -------------------------------------------------------------------

// RaftAcceptRequest

// uint32 from = 1;
inline void RaftAcceptRequest::clear_from() {
  from_ = 0u;
}
inline uint32_t RaftAcceptRequest::_internal_from() const {
  return from_;
}
inline uint32_t RaftAcceptRequest::from() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptRequest.from)
  return _internal_from();
}
inline void RaftAcceptRequest::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void RaftAcceptRequest::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptRequest.from)
}

// uint32 to = 2;
inline void RaftAcceptRequest::clear_to() {
  to_ = 0u;
}
inline uint32_t RaftAcceptRequest::_internal_to() const {
  return to_;
}
inline uint32_t RaftAcceptRequest::to() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptRequest.to)
  return _internal_to();
}
inline void RaftAcceptRequest::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void RaftAcceptRequest::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptRequest.to)
}

// uint64 epoch_id = 3;
inline void RaftAcceptRequest::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t RaftAcceptRequest::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t RaftAcceptRequest::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptRequest.epoch_id)
  return _internal_epoch_id();
}
inline void RaftAcceptRequest::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void RaftAcceptRequest::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptRequest.epoch_id)
}

// -------------------------------------------------------------------

// RaftCommitRequest

// uint32 from = 1;
inline void RaftCommitRequest::clear_from() {
  from_ = 0u;
}
inline uint32_t RaftCommitRequest::_internal_from() const {
  return from_;
}
inline uint32_t RaftCommitRequest::from() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitRequest.from)
  return _internal_from();
}
inline void RaftCommitRequest::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void RaftCommitRequest::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitRequest.from)
}

// uint32 to = 2;
inline void RaftCommitRequest::clear_to() {
  to_ = 0u;
}
inline uint32_t RaftCommitRequest::_internal_to() const {
  return to_;
}
inline uint32_t RaftCommitRequest::to() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitRequest.to)
  return _internal_to();
}
inline void RaftCommitRequest::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void RaftCommitRequest::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitRequest.to)
}

// uint64 epoch_id = 3;
inline void RaftCommitRequest::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t RaftCommitRequest::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t RaftCommitRequest::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitRequest.epoch_id)
  return _internal_epoch_id();
}
inline void RaftCommitRequest::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void RaftCommitRequest::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitRequest.epoch_id)
}

// -------------------------------------------------------------------

// StatsRequest

// uint32 from = 1;
inline void StatsRequest::clear_from() {
  from_ = 0u;
}
inline uint32_t StatsRequest::_internal_from() const {
  return from_;
}
inline uint32_t StatsRequest::from() const {
  // @@protoc_insertion_point(field_get:proto.StatsRequest.from)
  return _internal_from();
}
inline void StatsRequest::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void StatsRequest::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.StatsRequest.from)
}

// uint32 to = 2;
inline void StatsRequest::clear_to() {
  to_ = 0u;
}
inline uint32_t StatsRequest::_internal_to() const {
  return to_;
}
inline uint32_t StatsRequest::to() const {
  // @@protoc_insertion_point(field_get:proto.StatsRequest.to)
  return _internal_to();
}
inline void StatsRequest::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void StatsRequest::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.StatsRequest.to)
}

// uint32 level = 3;
inline void StatsRequest::clear_level() {
  level_ = 0u;
}
inline uint32_t StatsRequest::_internal_level() const {
  return level_;
}
inline uint32_t StatsRequest::level() const {
  // @@protoc_insertion_point(field_get:proto.StatsRequest.level)
  return _internal_level();
}
inline void StatsRequest::_internal_set_level(uint32_t value) {
  
  level_ = value;
}
inline void StatsRequest::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:proto.StatsRequest.level)
}

// -------------------------------------------------------------------

// ChangeServerStateRequest

// uint32 from = 1;
inline void ChangeServerStateRequest::clear_from() {
  from_ = 0u;
}
inline uint32_t ChangeServerStateRequest::_internal_from() const {
  return from_;
}
inline uint32_t ChangeServerStateRequest::from() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.from)
  return _internal_from();
}
inline void ChangeServerStateRequest::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void ChangeServerStateRequest::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.from)
}

// uint32 to = 2;
inline void ChangeServerStateRequest::clear_to() {
  to_ = 0u;
}
inline uint32_t ChangeServerStateRequest::_internal_to() const {
  return to_;
}
inline uint32_t ChangeServerStateRequest::to() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.to)
  return _internal_to();
}
inline void ChangeServerStateRequest::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void ChangeServerStateRequest::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.to)
}

// uint32 target = 3;
inline void ChangeServerStateRequest::clear_target() {
  target_ = 0u;
}
inline uint32_t ChangeServerStateRequest::_internal_target() const {
  return target_;
}
inline uint32_t ChangeServerStateRequest::target() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.target)
  return _internal_target();
}
inline void ChangeServerStateRequest::_internal_set_target(uint32_t value) {
  
  target_ = value;
}
inline void ChangeServerStateRequest::set_target(uint32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.target)
}

// uint32 state = 4;
inline void ChangeServerStateRequest::clear_state() {
  state_ = 0u;
}
inline uint32_t ChangeServerStateRequest::_internal_state() const {
  return state_;
}
inline uint32_t ChangeServerStateRequest::state() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.state)
  return _internal_state();
}
inline void ChangeServerStateRequest::_internal_set_state(uint32_t value) {
  
  state_ = value;
}
inline void ChangeServerStateRequest::set_state(uint32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.state)
}

// uint32 pull_server_id = 5;
inline void ChangeServerStateRequest::clear_pull_server_id() {
  pull_server_id_ = 0u;
}
inline uint32_t ChangeServerStateRequest::_internal_pull_server_id() const {
  return pull_server_id_;
}
inline uint32_t ChangeServerStateRequest::pull_server_id() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.pull_server_id)
  return _internal_pull_server_id();
}
inline void ChangeServerStateRequest::_internal_set_pull_server_id(uint32_t value) {
  
  pull_server_id_ = value;
}
inline void ChangeServerStateRequest::set_pull_server_id(uint32_t value) {
  _internal_set_pull_server_id(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.pull_server_id)
}

// uint64 epoch_id = 6;
inline void ChangeServerStateRequest::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t ChangeServerStateRequest::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t ChangeServerStateRequest::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateRequest.epoch_id)
  return _internal_epoch_id();
}
inline void ChangeServerStateRequest::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void ChangeServerStateRequest::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateRequest.epoch_id)
}

// -------------------------------------------------------------------

// RaftResponse

// .proto.Pong pong = 1;
inline bool RaftResponse::_internal_has_pong() const {
  return type_case() == kPong;
}
inline bool RaftResponse::has_pong() const {
  return _internal_has_pong();
}
inline void RaftResponse::set_has_pong() {
  _oneof_case_[0] = kPong;
}
inline void RaftResponse::clear_pong() {
  if (_internal_has_pong()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.pong_;
    }
    clear_has_type();
  }
}
inline ::proto::Pong* RaftResponse::release_pong() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.pong)
  if (_internal_has_pong()) {
    clear_has_type();
    ::proto::Pong* temp = type_.pong_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::Pong& RaftResponse::_internal_pong() const {
  return _internal_has_pong()
      ? *type_.pong_
      : reinterpret_cast< ::proto::Pong&>(::proto::_Pong_default_instance_);
}
inline const ::proto::Pong& RaftResponse::pong() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.pong)
  return _internal_pong();
}
inline ::proto::Pong* RaftResponse::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.pong)
  if (_internal_has_pong()) {
    clear_has_type();
    ::proto::Pong* temp = type_.pong_;
    type_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_pong(::proto::Pong* pong) {
  clear_type();
  if (pong) {
    set_has_pong();
    type_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.pong)
}
inline ::proto::Pong* RaftResponse::_internal_mutable_pong() {
  if (!_internal_has_pong()) {
    clear_type();
    set_has_pong();
    type_.pong_ = CreateMaybeMessage< ::proto::Pong >(GetArenaForAllocation());
  }
  return type_.pong_;
}
inline ::proto::Pong* RaftResponse::mutable_pong() {
  ::proto::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.pong)
  return _msg;
}

// .proto.LookupMasterResponse lookup_master = 2;
inline bool RaftResponse::_internal_has_lookup_master() const {
  return type_case() == kLookupMaster;
}
inline bool RaftResponse::has_lookup_master() const {
  return _internal_has_lookup_master();
}
inline void RaftResponse::set_has_lookup_master() {
  _oneof_case_[0] = kLookupMaster;
}
inline void RaftResponse::clear_lookup_master() {
  if (_internal_has_lookup_master()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.lookup_master_;
    }
    clear_has_type();
  }
}
inline ::proto::LookupMasterResponse* RaftResponse::release_lookup_master() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.lookup_master)
  if (_internal_has_lookup_master()) {
    clear_has_type();
    ::proto::LookupMasterResponse* temp = type_.lookup_master_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.lookup_master_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::LookupMasterResponse& RaftResponse::_internal_lookup_master() const {
  return _internal_has_lookup_master()
      ? *type_.lookup_master_
      : reinterpret_cast< ::proto::LookupMasterResponse&>(::proto::_LookupMasterResponse_default_instance_);
}
inline const ::proto::LookupMasterResponse& RaftResponse::lookup_master() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.lookup_master)
  return _internal_lookup_master();
}
inline ::proto::LookupMasterResponse* RaftResponse::unsafe_arena_release_lookup_master() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.lookup_master)
  if (_internal_has_lookup_master()) {
    clear_has_type();
    ::proto::LookupMasterResponse* temp = type_.lookup_master_;
    type_.lookup_master_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_lookup_master(::proto::LookupMasterResponse* lookup_master) {
  clear_type();
  if (lookup_master) {
    set_has_lookup_master();
    type_.lookup_master_ = lookup_master;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.lookup_master)
}
inline ::proto::LookupMasterResponse* RaftResponse::_internal_mutable_lookup_master() {
  if (!_internal_has_lookup_master()) {
    clear_type();
    set_has_lookup_master();
    type_.lookup_master_ = CreateMaybeMessage< ::proto::LookupMasterResponse >(GetArenaForAllocation());
  }
  return type_.lookup_master_;
}
inline ::proto::LookupMasterResponse* RaftResponse::mutable_lookup_master() {
  ::proto::LookupMasterResponse* _msg = _internal_mutable_lookup_master();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.lookup_master)
  return _msg;
}

// .proto.RaftAcceptResponse raft_accept = 3;
inline bool RaftResponse::_internal_has_raft_accept() const {
  return type_case() == kRaftAccept;
}
inline bool RaftResponse::has_raft_accept() const {
  return _internal_has_raft_accept();
}
inline void RaftResponse::set_has_raft_accept() {
  _oneof_case_[0] = kRaftAccept;
}
inline void RaftResponse::clear_raft_accept() {
  if (_internal_has_raft_accept()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.raft_accept_;
    }
    clear_has_type();
  }
}
inline ::proto::RaftAcceptResponse* RaftResponse::release_raft_accept() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.raft_accept)
  if (_internal_has_raft_accept()) {
    clear_has_type();
    ::proto::RaftAcceptResponse* temp = type_.raft_accept_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.raft_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::RaftAcceptResponse& RaftResponse::_internal_raft_accept() const {
  return _internal_has_raft_accept()
      ? *type_.raft_accept_
      : reinterpret_cast< ::proto::RaftAcceptResponse&>(::proto::_RaftAcceptResponse_default_instance_);
}
inline const ::proto::RaftAcceptResponse& RaftResponse::raft_accept() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.raft_accept)
  return _internal_raft_accept();
}
inline ::proto::RaftAcceptResponse* RaftResponse::unsafe_arena_release_raft_accept() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.raft_accept)
  if (_internal_has_raft_accept()) {
    clear_has_type();
    ::proto::RaftAcceptResponse* temp = type_.raft_accept_;
    type_.raft_accept_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_raft_accept(::proto::RaftAcceptResponse* raft_accept) {
  clear_type();
  if (raft_accept) {
    set_has_raft_accept();
    type_.raft_accept_ = raft_accept;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.raft_accept)
}
inline ::proto::RaftAcceptResponse* RaftResponse::_internal_mutable_raft_accept() {
  if (!_internal_has_raft_accept()) {
    clear_type();
    set_has_raft_accept();
    type_.raft_accept_ = CreateMaybeMessage< ::proto::RaftAcceptResponse >(GetArenaForAllocation());
  }
  return type_.raft_accept_;
}
inline ::proto::RaftAcceptResponse* RaftResponse::mutable_raft_accept() {
  ::proto::RaftAcceptResponse* _msg = _internal_mutable_raft_accept();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.raft_accept)
  return _msg;
}

// .proto.RaftCommitResponse raft_commit = 4;
inline bool RaftResponse::_internal_has_raft_commit() const {
  return type_case() == kRaftCommit;
}
inline bool RaftResponse::has_raft_commit() const {
  return _internal_has_raft_commit();
}
inline void RaftResponse::set_has_raft_commit() {
  _oneof_case_[0] = kRaftCommit;
}
inline void RaftResponse::clear_raft_commit() {
  if (_internal_has_raft_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.raft_commit_;
    }
    clear_has_type();
  }
}
inline ::proto::RaftCommitResponse* RaftResponse::release_raft_commit() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.raft_commit)
  if (_internal_has_raft_commit()) {
    clear_has_type();
    ::proto::RaftCommitResponse* temp = type_.raft_commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.raft_commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::RaftCommitResponse& RaftResponse::_internal_raft_commit() const {
  return _internal_has_raft_commit()
      ? *type_.raft_commit_
      : reinterpret_cast< ::proto::RaftCommitResponse&>(::proto::_RaftCommitResponse_default_instance_);
}
inline const ::proto::RaftCommitResponse& RaftResponse::raft_commit() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.raft_commit)
  return _internal_raft_commit();
}
inline ::proto::RaftCommitResponse* RaftResponse::unsafe_arena_release_raft_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.raft_commit)
  if (_internal_has_raft_commit()) {
    clear_has_type();
    ::proto::RaftCommitResponse* temp = type_.raft_commit_;
    type_.raft_commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_raft_commit(::proto::RaftCommitResponse* raft_commit) {
  clear_type();
  if (raft_commit) {
    set_has_raft_commit();
    type_.raft_commit_ = raft_commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.raft_commit)
}
inline ::proto::RaftCommitResponse* RaftResponse::_internal_mutable_raft_commit() {
  if (!_internal_has_raft_commit()) {
    clear_type();
    set_has_raft_commit();
    type_.raft_commit_ = CreateMaybeMessage< ::proto::RaftCommitResponse >(GetArenaForAllocation());
  }
  return type_.raft_commit_;
}
inline ::proto::RaftCommitResponse* RaftResponse::mutable_raft_commit() {
  ::proto::RaftCommitResponse* _msg = _internal_mutable_raft_commit();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.raft_commit)
  return _msg;
}

// .proto.StatsResponse stats = 5;
inline bool RaftResponse::_internal_has_stats() const {
  return type_case() == kStats;
}
inline bool RaftResponse::has_stats() const {
  return _internal_has_stats();
}
inline void RaftResponse::set_has_stats() {
  _oneof_case_[0] = kStats;
}
inline void RaftResponse::clear_stats() {
  if (_internal_has_stats()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.stats_;
    }
    clear_has_type();
  }
}
inline ::proto::StatsResponse* RaftResponse::release_stats() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.stats)
  if (_internal_has_stats()) {
    clear_has_type();
    ::proto::StatsResponse* temp = type_.stats_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::StatsResponse& RaftResponse::_internal_stats() const {
  return _internal_has_stats()
      ? *type_.stats_
      : reinterpret_cast< ::proto::StatsResponse&>(::proto::_StatsResponse_default_instance_);
}
inline const ::proto::StatsResponse& RaftResponse::stats() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.stats)
  return _internal_stats();
}
inline ::proto::StatsResponse* RaftResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.stats)
  if (_internal_has_stats()) {
    clear_has_type();
    ::proto::StatsResponse* temp = type_.stats_;
    type_.stats_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_stats(::proto::StatsResponse* stats) {
  clear_type();
  if (stats) {
    set_has_stats();
    type_.stats_ = stats;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.stats)
}
inline ::proto::StatsResponse* RaftResponse::_internal_mutable_stats() {
  if (!_internal_has_stats()) {
    clear_type();
    set_has_stats();
    type_.stats_ = CreateMaybeMessage< ::proto::StatsResponse >(GetArenaForAllocation());
  }
  return type_.stats_;
}
inline ::proto::StatsResponse* RaftResponse::mutable_stats() {
  ::proto::StatsResponse* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.stats)
  return _msg;
}

// .proto.ChangeServerStateResponse change_server_state = 6;
inline bool RaftResponse::_internal_has_change_server_state() const {
  return type_case() == kChangeServerState;
}
inline bool RaftResponse::has_change_server_state() const {
  return _internal_has_change_server_state();
}
inline void RaftResponse::set_has_change_server_state() {
  _oneof_case_[0] = kChangeServerState;
}
inline void RaftResponse::clear_change_server_state() {
  if (_internal_has_change_server_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.change_server_state_;
    }
    clear_has_type();
  }
}
inline ::proto::ChangeServerStateResponse* RaftResponse::release_change_server_state() {
  // @@protoc_insertion_point(field_release:proto.RaftResponse.change_server_state)
  if (_internal_has_change_server_state()) {
    clear_has_type();
    ::proto::ChangeServerStateResponse* temp = type_.change_server_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.change_server_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::proto::ChangeServerStateResponse& RaftResponse::_internal_change_server_state() const {
  return _internal_has_change_server_state()
      ? *type_.change_server_state_
      : reinterpret_cast< ::proto::ChangeServerStateResponse&>(::proto::_ChangeServerStateResponse_default_instance_);
}
inline const ::proto::ChangeServerStateResponse& RaftResponse::change_server_state() const {
  // @@protoc_insertion_point(field_get:proto.RaftResponse.change_server_state)
  return _internal_change_server_state();
}
inline ::proto::ChangeServerStateResponse* RaftResponse::unsafe_arena_release_change_server_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:proto.RaftResponse.change_server_state)
  if (_internal_has_change_server_state()) {
    clear_has_type();
    ::proto::ChangeServerStateResponse* temp = type_.change_server_state_;
    type_.change_server_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RaftResponse::unsafe_arena_set_allocated_change_server_state(::proto::ChangeServerStateResponse* change_server_state) {
  clear_type();
  if (change_server_state) {
    set_has_change_server_state();
    type_.change_server_state_ = change_server_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RaftResponse.change_server_state)
}
inline ::proto::ChangeServerStateResponse* RaftResponse::_internal_mutable_change_server_state() {
  if (!_internal_has_change_server_state()) {
    clear_type();
    set_has_change_server_state();
    type_.change_server_state_ = CreateMaybeMessage< ::proto::ChangeServerStateResponse >(GetArenaForAllocation());
  }
  return type_.change_server_state_;
}
inline ::proto::ChangeServerStateResponse* RaftResponse::mutable_change_server_state() {
  ::proto::ChangeServerStateResponse* _msg = _internal_mutable_change_server_state();
  // @@protoc_insertion_point(field_mutable:proto.RaftResponse.change_server_state)
  return _msg;
}

inline bool RaftResponse::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RaftResponse::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline RaftResponse::TypeCase RaftResponse::type_case() const {
  return RaftResponse::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Pong

// int32 from = 1;
inline void Pong::clear_from() {
  from_ = 0;
}
inline int32_t Pong::_internal_from() const {
  return from_;
}
inline int32_t Pong::from() const {
  // @@protoc_insertion_point(field_get:proto.Pong.from)
  return _internal_from();
}
inline void Pong::_internal_set_from(int32_t value) {
  
  from_ = value;
}
inline void Pong::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.Pong.from)
}

// int32 to = 2;
inline void Pong::clear_to() {
  to_ = 0;
}
inline int32_t Pong::_internal_to() const {
  return to_;
}
inline int32_t Pong::to() const {
  // @@protoc_insertion_point(field_get:proto.Pong.to)
  return _internal_to();
}
inline void Pong::_internal_set_to(int32_t value) {
  
  to_ = value;
}
inline void Pong::set_to(int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.Pong.to)
}

// int64 time = 3;
inline void Pong::clear_time() {
  time_ = int64_t{0};
}
inline int64_t Pong::_internal_time() const {
  return time_;
}
inline int64_t Pong::time() const {
  // @@protoc_insertion_point(field_get:proto.Pong.time)
  return _internal_time();
}
inline void Pong::_internal_set_time(int64_t value) {
  
  time_ = value;
}
inline void Pong::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:proto.Pong.time)
}

// int64 epoch_id = 4;
inline void Pong::clear_epoch_id() {
  epoch_id_ = int64_t{0};
}
inline int64_t Pong::_internal_epoch_id() const {
  return epoch_id_;
}
inline int64_t Pong::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.Pong.epoch_id)
  return _internal_epoch_id();
}
inline void Pong::_internal_set_epoch_id(int64_t value) {
  
  epoch_id_ = value;
}
inline void Pong::set_epoch_id(int64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.Pong.epoch_id)
}

// -------------------------------------------------------------------

// MasterMetadata

// uint32 master = 1;
inline void MasterMetadata::clear_master() {
  master_ = 0u;
}
inline uint32_t MasterMetadata::_internal_master() const {
  return master_;
}
inline uint32_t MasterMetadata::master() const {
  // @@protoc_insertion_point(field_get:proto.MasterMetadata.master)
  return _internal_master();
}
inline void MasterMetadata::_internal_set_master(uint32_t value) {
  
  master_ = value;
}
inline void MasterMetadata::set_master(uint32_t value) {
  _internal_set_master(value);
  // @@protoc_insertion_point(field_set:proto.MasterMetadata.master)
}

// uint32 epoch_count = 2;
inline void MasterMetadata::clear_epoch_count() {
  epoch_count_ = 0u;
}
inline uint32_t MasterMetadata::_internal_epoch_count() const {
  return epoch_count_;
}
inline uint32_t MasterMetadata::epoch_count() const {
  // @@protoc_insertion_point(field_get:proto.MasterMetadata.epoch_count)
  return _internal_epoch_count();
}
inline void MasterMetadata::_internal_set_epoch_count(uint32_t value) {
  
  epoch_count_ = value;
}
inline void MasterMetadata::set_epoch_count(uint32_t value) {
  _internal_set_epoch_count(value);
  // @@protoc_insertion_point(field_set:proto.MasterMetadata.epoch_count)
}

// -------------------------------------------------------------------

// KeyMasterMetadata

// bytes key = 1;
inline void KeyMasterMetadata::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyMasterMetadata::key() const {
  // @@protoc_insertion_point(field_get:proto.KeyMasterMetadata.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyMasterMetadata::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.KeyMasterMetadata.key)
}
inline std::string* KeyMasterMetadata::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:proto.KeyMasterMetadata.key)
  return _s;
}
inline const std::string& KeyMasterMetadata::_internal_key() const {
  return key_.Get();
}
inline void KeyMasterMetadata::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyMasterMetadata::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyMasterMetadata::release_key() {
  // @@protoc_insertion_point(field_release:proto.KeyMasterMetadata.key)
  return key_.Release();
}
inline void KeyMasterMetadata::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.KeyMasterMetadata.key)
}

// .proto.MasterMetadata metadata = 2;
inline bool KeyMasterMetadata::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool KeyMasterMetadata::has_metadata() const {
  return _internal_has_metadata();
}
inline void KeyMasterMetadata::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::proto::MasterMetadata& KeyMasterMetadata::_internal_metadata() const {
  const ::proto::MasterMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::MasterMetadata&>(
      ::proto::_MasterMetadata_default_instance_);
}
inline const ::proto::MasterMetadata& KeyMasterMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:proto.KeyMasterMetadata.metadata)
  return _internal_metadata();
}
inline void KeyMasterMetadata::unsafe_arena_set_allocated_metadata(
    ::proto::MasterMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.KeyMasterMetadata.metadata)
}
inline ::proto::MasterMetadata* KeyMasterMetadata::release_metadata() {
  
  ::proto::MasterMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::MasterMetadata* KeyMasterMetadata::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:proto.KeyMasterMetadata.metadata)
  
  ::proto::MasterMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::proto::MasterMetadata* KeyMasterMetadata::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::MasterMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::proto::MasterMetadata* KeyMasterMetadata::mutable_metadata() {
  ::proto::MasterMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:proto.KeyMasterMetadata.metadata)
  return _msg;
}
inline void KeyMasterMetadata::set_allocated_metadata(::proto::MasterMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:proto.KeyMasterMetadata.metadata)
}

// -------------------------------------------------------------------

// LookupMasterResponse

// repeated uint64 epoch_id = 1;
inline int LookupMasterResponse::_internal_epoch_id_size() const {
  return epoch_id_.size();
}
inline int LookupMasterResponse::epoch_id_size() const {
  return _internal_epoch_id_size();
}
inline void LookupMasterResponse::clear_epoch_id() {
  epoch_id_.Clear();
}
inline uint64_t LookupMasterResponse::_internal_epoch_id(int index) const {
  return epoch_id_.Get(index);
}
inline uint64_t LookupMasterResponse::epoch_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.LookupMasterResponse.epoch_id)
  return _internal_epoch_id(index);
}
inline void LookupMasterResponse::set_epoch_id(int index, uint64_t value) {
  epoch_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.LookupMasterResponse.epoch_id)
}
inline void LookupMasterResponse::_internal_add_epoch_id(uint64_t value) {
  epoch_id_.Add(value);
}
inline void LookupMasterResponse::add_epoch_id(uint64_t value) {
  _internal_add_epoch_id(value);
  // @@protoc_insertion_point(field_add:proto.LookupMasterResponse.epoch_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LookupMasterResponse::_internal_epoch_id() const {
  return epoch_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LookupMasterResponse::epoch_id() const {
  // @@protoc_insertion_point(field_list:proto.LookupMasterResponse.epoch_id)
  return _internal_epoch_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LookupMasterResponse::_internal_mutable_epoch_id() {
  return &epoch_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LookupMasterResponse::mutable_epoch_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.LookupMasterResponse.epoch_id)
  return _internal_mutable_epoch_id();
}

// repeated .proto.KeyMasterMetadata lookup_results = 2;
inline int LookupMasterResponse::_internal_lookup_results_size() const {
  return lookup_results_.size();
}
inline int LookupMasterResponse::lookup_results_size() const {
  return _internal_lookup_results_size();
}
inline void LookupMasterResponse::clear_lookup_results() {
  lookup_results_.Clear();
}
inline ::proto::KeyMasterMetadata* LookupMasterResponse::mutable_lookup_results(int index) {
  // @@protoc_insertion_point(field_mutable:proto.LookupMasterResponse.lookup_results)
  return lookup_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::KeyMasterMetadata >*
LookupMasterResponse::mutable_lookup_results() {
  // @@protoc_insertion_point(field_mutable_list:proto.LookupMasterResponse.lookup_results)
  return &lookup_results_;
}
inline const ::proto::KeyMasterMetadata& LookupMasterResponse::_internal_lookup_results(int index) const {
  return lookup_results_.Get(index);
}
inline const ::proto::KeyMasterMetadata& LookupMasterResponse::lookup_results(int index) const {
  // @@protoc_insertion_point(field_get:proto.LookupMasterResponse.lookup_results)
  return _internal_lookup_results(index);
}
inline ::proto::KeyMasterMetadata* LookupMasterResponse::_internal_add_lookup_results() {
  return lookup_results_.Add();
}
inline ::proto::KeyMasterMetadata* LookupMasterResponse::add_lookup_results() {
  ::proto::KeyMasterMetadata* _add = _internal_add_lookup_results();
  // @@protoc_insertion_point(field_add:proto.LookupMasterResponse.lookup_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::KeyMasterMetadata >&
LookupMasterResponse::lookup_results() const {
  // @@protoc_insertion_point(field_list:proto.LookupMasterResponse.lookup_results)
  return lookup_results_;
}

// -------------------------------------------------------------------

// RaftAcceptResponse

// uint32 from = 1;
inline void RaftAcceptResponse::clear_from() {
  from_ = 0u;
}
inline uint32_t RaftAcceptResponse::_internal_from() const {
  return from_;
}
inline uint32_t RaftAcceptResponse::from() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptResponse.from)
  return _internal_from();
}
inline void RaftAcceptResponse::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void RaftAcceptResponse::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptResponse.from)
}

// uint32 to = 2;
inline void RaftAcceptResponse::clear_to() {
  to_ = 0u;
}
inline uint32_t RaftAcceptResponse::_internal_to() const {
  return to_;
}
inline uint32_t RaftAcceptResponse::to() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptResponse.to)
  return _internal_to();
}
inline void RaftAcceptResponse::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void RaftAcceptResponse::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptResponse.to)
}

// uint64 epoch_id = 3;
inline void RaftAcceptResponse::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t RaftAcceptResponse::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t RaftAcceptResponse::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptResponse.epoch_id)
  return _internal_epoch_id();
}
inline void RaftAcceptResponse::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void RaftAcceptResponse::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptResponse.epoch_id)
}

// uint32 result = 4;
inline void RaftAcceptResponse::clear_result() {
  result_ = 0u;
}
inline uint32_t RaftAcceptResponse::_internal_result() const {
  return result_;
}
inline uint32_t RaftAcceptResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.RaftAcceptResponse.result)
  return _internal_result();
}
inline void RaftAcceptResponse::_internal_set_result(uint32_t value) {
  
  result_ = value;
}
inline void RaftAcceptResponse::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:proto.RaftAcceptResponse.result)
}

// -------------------------------------------------------------------

// RaftCommitResponse

// uint32 from = 1;
inline void RaftCommitResponse::clear_from() {
  from_ = 0u;
}
inline uint32_t RaftCommitResponse::_internal_from() const {
  return from_;
}
inline uint32_t RaftCommitResponse::from() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitResponse.from)
  return _internal_from();
}
inline void RaftCommitResponse::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void RaftCommitResponse::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitResponse.from)
}

// uint32 to = 2;
inline void RaftCommitResponse::clear_to() {
  to_ = 0u;
}
inline uint32_t RaftCommitResponse::_internal_to() const {
  return to_;
}
inline uint32_t RaftCommitResponse::to() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitResponse.to)
  return _internal_to();
}
inline void RaftCommitResponse::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void RaftCommitResponse::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitResponse.to)
}

// uint64 epoch_id = 3;
inline void RaftCommitResponse::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t RaftCommitResponse::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t RaftCommitResponse::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitResponse.epoch_id)
  return _internal_epoch_id();
}
inline void RaftCommitResponse::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void RaftCommitResponse::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitResponse.epoch_id)
}

// uint32 result = 4;
inline void RaftCommitResponse::clear_result() {
  result_ = 0u;
}
inline uint32_t RaftCommitResponse::_internal_result() const {
  return result_;
}
inline uint32_t RaftCommitResponse::result() const {
  // @@protoc_insertion_point(field_get:proto.RaftCommitResponse.result)
  return _internal_result();
}
inline void RaftCommitResponse::_internal_set_result(uint32_t value) {
  
  result_ = value;
}
inline void RaftCommitResponse::set_result(uint32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:proto.RaftCommitResponse.result)
}

// -------------------------------------------------------------------

// StatsResponse

// uint32 from = 1;
inline void StatsResponse::clear_from() {
  from_ = 0u;
}
inline uint32_t StatsResponse::_internal_from() const {
  return from_;
}
inline uint32_t StatsResponse::from() const {
  // @@protoc_insertion_point(field_get:proto.StatsResponse.from)
  return _internal_from();
}
inline void StatsResponse::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void StatsResponse::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.StatsResponse.from)
}

// uint64 to = 2;
inline void StatsResponse::clear_to() {
  to_ = uint64_t{0u};
}
inline uint64_t StatsResponse::_internal_to() const {
  return to_;
}
inline uint64_t StatsResponse::to() const {
  // @@protoc_insertion_point(field_get:proto.StatsResponse.to)
  return _internal_to();
}
inline void StatsResponse::_internal_set_to(uint64_t value) {
  
  to_ = value;
}
inline void StatsResponse::set_to(uint64_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.StatsResponse.to)
}

// uint64 epoch_id = 3;
inline void StatsResponse::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t StatsResponse::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t StatsResponse::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.StatsResponse.epoch_id)
  return _internal_epoch_id();
}
inline void StatsResponse::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void StatsResponse::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.StatsResponse.epoch_id)
}

// -------------------------------------------------------------------

// ChangeServerStateResponse

// uint32 from = 1;
inline void ChangeServerStateResponse::clear_from() {
  from_ = 0u;
}
inline uint32_t ChangeServerStateResponse::_internal_from() const {
  return from_;
}
inline uint32_t ChangeServerStateResponse::from() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateResponse.from)
  return _internal_from();
}
inline void ChangeServerStateResponse::_internal_set_from(uint32_t value) {
  
  from_ = value;
}
inline void ChangeServerStateResponse::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateResponse.from)
}

// uint32 to = 2;
inline void ChangeServerStateResponse::clear_to() {
  to_ = 0u;
}
inline uint32_t ChangeServerStateResponse::_internal_to() const {
  return to_;
}
inline uint32_t ChangeServerStateResponse::to() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateResponse.to)
  return _internal_to();
}
inline void ChangeServerStateResponse::_internal_set_to(uint32_t value) {
  
  to_ = value;
}
inline void ChangeServerStateResponse::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateResponse.to)
}

// uint32 target = 3;
inline void ChangeServerStateResponse::clear_target() {
  target_ = 0u;
}
inline uint32_t ChangeServerStateResponse::_internal_target() const {
  return target_;
}
inline uint32_t ChangeServerStateResponse::target() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateResponse.target)
  return _internal_target();
}
inline void ChangeServerStateResponse::_internal_set_target(uint32_t value) {
  
  target_ = value;
}
inline void ChangeServerStateResponse::set_target(uint32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateResponse.target)
}

// uint64 epoch_id = 4;
inline void ChangeServerStateResponse::clear_epoch_id() {
  epoch_id_ = uint64_t{0u};
}
inline uint64_t ChangeServerStateResponse::_internal_epoch_id() const {
  return epoch_id_;
}
inline uint64_t ChangeServerStateResponse::epoch_id() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateResponse.epoch_id)
  return _internal_epoch_id();
}
inline void ChangeServerStateResponse::_internal_set_epoch_id(uint64_t value) {
  
  epoch_id_ = value;
}
inline void ChangeServerStateResponse::set_epoch_id(uint64_t value) {
  _internal_set_epoch_id(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateResponse.epoch_id)
}

// uint32 state = 5;
inline void ChangeServerStateResponse::clear_state() {
  state_ = 0u;
}
inline uint32_t ChangeServerStateResponse::_internal_state() const {
  return state_;
}
inline uint32_t ChangeServerStateResponse::state() const {
  // @@protoc_insertion_point(field_get:proto.ChangeServerStateResponse.state)
  return _internal_state();
}
inline void ChangeServerStateResponse::_internal_set_state(uint32_t value) {
  
  state_ = value;
}
inline void ChangeServerStateResponse::set_state(uint32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:proto.ChangeServerStateResponse.state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fserver_2eproto
